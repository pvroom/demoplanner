/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/es5processor", ["require", "exports", "path", "tsickle/src/fileoverview_comment_transformer", "tsickle/src/rewriter", "tsickle/src/typescript", "tsickle/src/util"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path = require("path");
    var fileoverview_comment_transformer_1 = require("tsickle/src/fileoverview_comment_transformer");
    var rewriter_1 = require("tsickle/src/rewriter");
    var ts = require("tsickle/src/typescript");
    var util_1 = require("tsickle/src/util");
    // Matches common extensions of TypeScript input filenames
    var TS_EXTENSIONS = /(\.ts|\.d\.ts|\.js|\.jsx|\.tsx)$/;
    /**
     * Extracts the namespace part of a goog: import, or returns null if the given
     * import is not a goog: import.
     */
    function extractGoogNamespaceImport(tsImport) {
        if (tsImport.match(/^goog:/))
            return tsImport.substring('goog:'.length);
        return null;
    }
    exports.extractGoogNamespaceImport = extractGoogNamespaceImport;
    /**
     * Convert from implicit `import {} from 'pkg'` to `import {} from 'pkg/index'.
     * TypeScript supports the shorthand, but not all ES6 module loaders do.
     * Workaround for https://github.com/Microsoft/TypeScript/issues/12597
     */
    function resolveIndexShorthand(host, fileName, imported) {
        var resolved = ts.resolveModuleName(imported, fileName, host.options, host.host);
        if (!resolved || !resolved.resolvedModule)
            return imported;
        var requestedModule = imported.replace(TS_EXTENSIONS, '');
        var resolvedModule = resolved.resolvedModule.resolvedFileName.replace(TS_EXTENSIONS, '');
        if (resolvedModule.indexOf('node_modules') === -1 &&
            requestedModule.substr(requestedModule.lastIndexOf('/')) !==
                resolvedModule.substr(resolvedModule.lastIndexOf('/'))) {
            imported = './' + path.relative(path.dirname(fileName), resolvedModule).replace(path.sep, '/');
        }
        return imported;
    }
    exports.resolveIndexShorthand = resolveIndexShorthand;
    /**
     * ES5Processor postprocesses the compilation output from TSC. It rewrites commonjs require()s
     * into goog.require(). Contrary to its name it handles converting the modules in both ES5
     * and ES6 outputs.
     */
    var ES5Processor = /** @class */ (function (_super) {
        __extends(ES5Processor, _super);
        function ES5Processor(host, file) {
            var _this = _super.call(this, file) || this;
            _this.host = host;
            /**
             * namespaceImports collects the variables for imported goog.modules.
             * If the original TS input is:
             *   import foo from 'goog:bar';
             * then TS produces:
             *   var foo = require('goog:bar');
             * and this class rewrites it to:
             *   var foo = require('goog.bar');
             * After this step, namespaceImports['foo'] is true.
             * (This is used to rewrite 'foo.default' into just 'foo'.)
             */
            _this.namespaceImports = new Set();
            /**
             * moduleVariables maps from module names to the variables they're assigned to.
             * Continuing the above example, moduleVariables['goog.bar'] = 'foo'.
             */
            _this.moduleVariables = new Map();
            /** strippedStrict is true once we've stripped a "use strict"; from the input. */
            _this.strippedStrict = false;
            /** unusedIndex is used to generate fresh symbols for unnamed imports. */
            _this.unusedIndex = 0;
            return _this;
        }
        ES5Processor.prototype.process = function () {
            var _this = this;
            this.emitFileComment();
            var moduleId = this.host.fileNameToModuleId(this.file.fileName);
            // The goog.module() call should not be emitted if the file is the result
            // of transpiling JS sources. Emitting goog.module() would change the semantics
            // of the file.
            if (!this.host.isJsTranspilation) {
                var moduleName = this.host.pathToModuleName('', this.file.fileName);
                // NB: No linebreak after module call so sourcemaps are not offset.
                this.emit("goog.module('" + moduleName + "');");
            }
            if (this.host.prelude)
                this.emit(this.host.prelude);
            // Allow code to use `module.id` to discover its module URL, e.g. to resolve
            // a template URL against.
            // Uses 'var', as this code is inserted in ES6 and ES5 modes.
            // The following pattern ensures closure doesn't throw an error in advanced
            // optimizations mode.
            if (this.host.es5Mode) {
                if (!this.host.isJsTranspilation) {
                    this.emit("var module = module || {id: '" + moduleId + "'};");
                }
            }
            else {
                // The `exports = {}` serves as a default export to disable Closure Compiler's error checking
                // for mutable exports. That's OK because TS compiler makes sure that consuming code always
                // accesses exports through the module object, so mutable exports work.
                // It is only inserted in ES6 because we strip `.default` accesses in ES5 mode, which breaks
                // when assigning an `exports = {}` object and then later accessing it.
                // However Closure bails if code later on assigns into exports directly, as we do if we have
                // an "exports = " block, so skip emit if that's the case.
                if (!this.file.statements.find(function (s) { return ts.isExpressionStatement(s) && _this.isModuleExportsAssignment(s); })) {
                    this.emit(" exports = {};");
                }
                // The module=module bit suppresses an unused variable warning which
                // may trigger depending on the compilation flags.
                this.emit(" var module = module || {id: '" + moduleId + "'}; module = module;");
            }
            var pos = 0;
            try {
                for (var _a = __values(this.file.statements), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var stmt = _b.value;
                    this.writeRange(this.file, pos, stmt.getFullStart());
                    this.visitTopLevel(stmt);
                    pos = stmt.getEnd();
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.writeRange(this.file, pos, this.file.getEnd());
            var referencedModules = Array.from(this.moduleVariables.keys());
            // Note: don't sort referencedModules, as the keys are in the same order
            // they occur in the source file.
            var output = this.getOutput().output;
            return { output: output, referencedModules: referencedModules };
            var e_1, _c;
        };
        /** Emits file comments for the current source file, if any. */
        ES5Processor.prototype.emitFileComment = function () {
            var _this = this;
            var leadingComments = ts.getLeadingCommentRanges(this.file.getFullText(), 0) || [];
            var fileComment = leadingComments.find(function (c) {
                if (c.kind !== ts.SyntaxKind.MultiLineCommentTrivia)
                    return false;
                var commentText = _this.file.getFullText().substring(c.pos, c.end);
                return fileoverview_comment_transformer_1.isClosureFileoverviewComment(commentText);
            });
            if (!fileComment)
                return;
            var end = fileComment.end;
            if (fileComment.hasTrailingNewLine)
                end++;
            this.writeLeadingTrivia(this.file, end);
        };
        /**
         * visitTopLevel processes a top-level ts.Node and emits its contents.
         *
         * It's separate from the normal Rewriter recursive traversal
         * because some top-level statements are handled specially.
         */
        ES5Processor.prototype.visitTopLevel = function (node) {
            switch (node.kind) {
                case ts.SyntaxKind.ExpressionStatement:
                    var exprStatement = node;
                    // Check for "use strict" and skip it if necessary.
                    if (!this.strippedStrict && this.isUseStrict(node)) {
                        this.emitCommentWithoutStatementBody(node);
                        this.strippedStrict = true;
                        return;
                    }
                    // Check for:
                    // - "require('foo');" (a require for its side effects)
                    // - "__export(require(...));" (an "export * from ...")
                    if (this.emitRewrittenRequires(node)) {
                        return;
                    }
                    // Check for
                    //   Object.defineProperty(exports, "__esModule", ...);
                    if (this.isEsModuleProperty(exprStatement)) {
                        this.emitCommentWithoutStatementBody(node);
                        return;
                    }
                    // Check for
                    //   module.exports = ...;
                    // Rewrite to goog.module's
                    //   exports = ...;
                    if (this.isModuleExportsAssignment(exprStatement)) {
                        this.emitExportsAssignment(exprStatement);
                        return;
                    }
                    // Otherwise fall through to default processing.
                    break;
                case ts.SyntaxKind.VariableStatement:
                    // Check for a "var x = require('foo');".
                    if (this.emitRewrittenRequires(node))
                        return;
                    break;
                default:
                    break;
            }
            this.visit(node);
        };
        /**
         * The TypeScript AST attaches comments to statement nodes, so even if a node
         * contains code we want to skip emitting, we need to emit the attached
         * comment(s).
         */
        ES5Processor.prototype.emitCommentWithoutStatementBody = function (node) {
            this.writeLeadingTrivia(node);
        };
        /** isUseStrict returns true if node is a "use strict"; statement. */
        ES5Processor.prototype.isUseStrict = function (node) {
            if (node.kind !== ts.SyntaxKind.ExpressionStatement)
                return false;
            var exprStmt = node;
            var expr = exprStmt.expression;
            if (expr.kind !== ts.SyntaxKind.StringLiteral)
                return false;
            var literal = expr;
            return literal.text === 'use strict';
        };
        /**
         * emitRewrittenRequires rewrites require()s into goog.require() equivalents.
         *
         * @return True if the node was rewritten, false if needs ordinary processing.
         */
        ES5Processor.prototype.emitRewrittenRequires = function (node) {
            // We're looking for requires, of one of the forms:
            // - "var importName = require(...);".
            // - "require(...);".
            if (node.kind === ts.SyntaxKind.VariableStatement) {
                // It's possibly of the form "var x = require(...);".
                var varStmt = node;
                // Verify it's a single decl (and not "var x = ..., y = ...;").
                if (varStmt.declarationList.declarations.length !== 1)
                    return false;
                var decl = varStmt.declarationList.declarations[0];
                // Grab the variable name (avoiding things like destructuring binds).
                if (decl.name.kind !== ts.SyntaxKind.Identifier)
                    return false;
                var varName = rewriter_1.getIdentifierText(decl.name);
                if (!decl.initializer || decl.initializer.kind !== ts.SyntaxKind.CallExpression)
                    return false;
                var call = decl.initializer;
                var require_1 = this.extractRequire(call);
                if (!require_1)
                    return false;
                // In JS transpilation, the only require('...') that needs to be
                // rewritten is require('tslib'), which is emitted by TSC when loading
                // ES6 polyfills.
                if (this.host.isJsTranspilation && require_1 !== 'tslib')
                    return false;
                this.writeLeadingTrivia(node);
                this.emitGoogRequire(varName, require_1);
                return true;
            }
            else if (node.kind === ts.SyntaxKind.ExpressionStatement) {
                // It's possibly of the form:
                // - require(...);
                // - __export(require(...));
                // - tslib_1.__exportStar(require(...));
                // All are CallExpressions.
                var exprStmt = node;
                var expr = exprStmt.expression;
                if (expr.kind !== ts.SyntaxKind.CallExpression)
                    return false;
                var call = expr;
                var require_2 = this.extractRequire(call);
                var isExport = false;
                if (!require_2) {
                    // If it's an __export(require(...)), we emit:
                    //   var x = require(...);
                    //   __export(x);
                    // This extra variable is necessary in case there's a later import of the
                    // same module name.
                    var innerCall = this.isExportRequire(call);
                    if (!innerCall)
                        return false;
                    isExport = true;
                    call = innerCall; // Update call to point at the require() expression.
                    require_2 = this.extractRequire(call);
                }
                if (!require_2)
                    return false;
                // In JS transpilation, the only require('...') that needs to be
                // rewritten is require('tslib'), which is emitted by TSC when loading
                // ES6 polyfills.
                if (this.host.isJsTranspilation && require_2 !== 'tslib')
                    return false;
                this.writeLeadingTrivia(node);
                var varName = this.emitGoogRequire(null, require_2);
                if (isExport) {
                    // node is a statement containing a require() in it, while
                    // requireCall is that call.  We replace the require() call
                    // with the variable we emitted.
                    var fullStatement = node.getText();
                    var requireCall = call.getText();
                    this.emit(fullStatement.replace(requireCall, varName));
                }
                return true;
            }
            else {
                // It's some other type of statement.
                return false;
            }
        };
        /**
         * Emits a goog.require() statement for a given variable name and TypeScript import.
         *
         * E.g. from:
         *   var varName = require('tsImport');
         * produces:
         *   var varName = goog.require('goog.module.name');
         *
         * If the input varName is null, generates a new variable name if necessary.
         *
         * @return The variable name for the imported module, reusing a previous import if one
         *    is available.
         */
        ES5Processor.prototype.emitGoogRequire = function (varName, tsImport) {
            var modName;
            var isNamespaceImport = false;
            var nsImport = extractGoogNamespaceImport(tsImport);
            if (nsImport !== null) {
                // This is a namespace import, of the form "goog:foo.bar".
                // Fix it to just "foo.bar".
                modName = nsImport;
                isNamespaceImport = true;
            }
            else {
                if (this.host.convertIndexImportShorthand) {
                    tsImport = resolveIndexShorthand(this.host, this.file.fileName, tsImport);
                }
                modName = this.host.pathToModuleName(this.file.fileName, tsImport);
            }
            if (!varName) {
                var mv = this.moduleVariables.get(modName);
                if (mv) {
                    // Caller didn't request a specific variable name and we've already
                    // imported the module, so just return the name we already have for this module.
                    return mv;
                }
                // Note: we always introduce a variable for any import, regardless of whether
                // the caller requested one.  This avoids a Closure error.
                varName = this.generateFreshVariableName();
            }
            if (isNamespaceImport)
                this.namespaceImports.add(varName);
            if (this.moduleVariables.has(modName)) {
                this.emit("var " + varName + " = " + this.moduleVariables.get(modName) + ";");
            }
            else {
                this.emit("var " + varName + " = goog.require('" + modName + "');");
                this.moduleVariables.set(modName, varName);
            }
            return varName;
        };
        // workaround for syntax highlighting bug in Sublime: `
        /**
         * Returns the string argument if call is of the form
         *   require('foo')
         */
        ES5Processor.prototype.extractRequire = function (call) {
            // Verify that the call is a call to require(...).
            if (call.expression.kind !== ts.SyntaxKind.Identifier)
                return null;
            var ident = call.expression;
            if (rewriter_1.getIdentifierText(ident) !== 'require')
                return null;
            // Verify the call takes a single string argument and grab it.
            if (call.arguments.length !== 1)
                return null;
            var arg = call.arguments[0];
            if (arg.kind !== ts.SyntaxKind.StringLiteral)
                return null;
            return arg.text;
        };
        /**
         * Returns the require() call node if the outer call is of the forms:
         * - __export(require('foo'))
         * - tslib_1.__exportStar(require('foo'), bar)
         */
        ES5Processor.prototype.isExportRequire = function (call) {
            switch (call.expression.kind) {
                case ts.SyntaxKind.Identifier:
                    var ident = call.expression;
                    // TS_24_COMPAT: accept three leading underscores
                    if (ident.text !== '__export' && ident.text !== '___export') {
                        return null;
                    }
                    break;
                case ts.SyntaxKind.PropertyAccessExpression:
                    var propAccess = call.expression;
                    // TS_24_COMPAT: accept three leading underscores
                    if (propAccess.name.text !== '__exportStar' && propAccess.name.text !== '___exportStar') {
                        return null;
                    }
                    break;
                default:
                    return null;
            }
            // Verify the call takes at least one argument and check it.
            if (call.arguments.length < 1)
                return null;
            var arg = call.arguments[0];
            if (arg.kind !== ts.SyntaxKind.CallExpression)
                return null;
            var innerCall = arg;
            if (!this.extractRequire(innerCall))
                return null;
            return innerCall;
        };
        ES5Processor.prototype.isEsModuleProperty = function (expr) {
            // We're matching the explicit source text generated by the TS compiler.
            return expr.getText() === 'Object.defineProperty(exports, "__esModule", { value: true });';
        };
        ES5Processor.prototype.isModuleExportsAssignment = function (expr) {
            // Looking for "module.exports = ...;"
            if (!ts.isBinaryExpression(expr.expression))
                return false;
            if (expr.expression.operatorToken.kind !== ts.SyntaxKind.EqualsToken)
                return false;
            return expr.expression.left.getText() === 'module.exports';
        };
        ES5Processor.prototype.emitExportsAssignment = function (expr) {
            this.emitCommentWithoutStatementBody(expr);
            this.emit('exports =');
            this.visit(expr.expression.right);
            this.emit(';');
        };
        /**
         * maybeProcess is called during the recursive traversal of the program's AST.
         *
         * @return True if the node was processed/emitted, false if it should be emitted as is.
         */
        ES5Processor.prototype.maybeProcess = function (node) {
            switch (node.kind) {
                case ts.SyntaxKind.PropertyAccessExpression:
                    var propAccess = node;
                    // We're looking for an expression of the form:
                    //   module_name_var.default
                    if (rewriter_1.getIdentifierText(propAccess.name) !== 'default')
                        break;
                    if (propAccess.expression.kind !== ts.SyntaxKind.Identifier)
                        break;
                    var lhs = rewriter_1.getIdentifierText(propAccess.expression);
                    if (!this.namespaceImports.has(lhs))
                        break;
                    // Emit the same expression, with spaces to replace the ".default" part
                    // so that source maps still line up.
                    this.writeLeadingTrivia(node);
                    this.emit(lhs + "        ");
                    return true;
                default:
                    break;
            }
            return false;
        };
        /** Generates a new variable name inside the tsickle_ namespace. */
        ES5Processor.prototype.generateFreshVariableName = function () {
            return "tsickle_module_" + this.unusedIndex++ + "_";
        };
        return ES5Processor;
    }(rewriter_1.Rewriter));
    /**
     * Converts TypeScript's JS+CommonJS output to Closure goog.module etc.
     * For use as a postprocessing step *after* TypeScript emits JavaScript.
     *
     * @param fileName The source file name.
     * @param moduleId The "module id", a module-identifying string that is
     *     the value module.id in the scope of the module.
     * @param pathToModuleName A function that maps a filesystem .ts path to a
     *     Closure module name, as found in a goog.require('...') statement.
     *     The context parameter is the referencing file, used for resolving
     *     imports with relative paths like "import * as foo from '../foo';".
     * @param prelude An additional prelude to insert after the `goog.module` call,
     *     e.g. with additional imports or requires.
     */
    function processES5(host, fileName, content) {
        var file = ts.createSourceFile(fileName, content, ts.ScriptTarget.ES5, true);
        return new ES5Processor(host, file).process();
    }
    exports.processES5 = processES5;
    function convertCommonJsToGoogModuleIfNeeded(host, modulesManifest, fileName, content) {
        if (!host.googmodule || util_1.isDtsFileName(fileName)) {
            return content;
        }
        var _a = processES5(host, fileName, content), output = _a.output, referencedModules = _a.referencedModules;
        var moduleName = host.pathToModuleName('', fileName);
        modulesManifest.addModule(fileName, moduleName);
        try {
            for (var referencedModules_1 = __values(referencedModules), referencedModules_1_1 = referencedModules_1.next(); !referencedModules_1_1.done; referencedModules_1_1 = referencedModules_1.next()) {
                var referenced = referencedModules_1_1.value;
                modulesManifest.addReferencedModule(fileName, referenced);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (referencedModules_1_1 && !referencedModules_1_1.done && (_b = referencedModules_1.return)) _b.call(referencedModules_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return output;
        var e_2, _b;
    }
    exports.convertCommonJsToGoogModuleIfNeeded = convertCommonJsToGoogModuleIfNeeded;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXM1cHJvY2Vzc29yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2VzNXByb2Nlc3Nvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBRUgsMkJBQTZCO0lBRTdCLGlHQUFnRjtJQUVoRixpREFBdUQ7SUFDdkQsMkNBQW1DO0lBQ25DLHlDQUFxQztJQUVyQywwREFBMEQ7SUFDMUQsSUFBTSxhQUFhLEdBQUcsa0NBQWtDLENBQUM7SUErQnpEOzs7T0FHRztJQUNILG9DQUEyQyxRQUFnQjtRQUN6RCxJQUFJLFFBQVEsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDO1lBQUUsT0FBTyxRQUFRLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN4RSxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFIRCxnRUFHQztJQUVEOzs7O09BSUc7SUFDSCwrQkFDSSxJQUFrRSxFQUFFLFFBQWdCLEVBQ3BGLFFBQWdCO1FBQ2xCLElBQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ25GLElBQUksQ0FBQyxRQUFRLElBQUksQ0FBQyxRQUFRLENBQUMsY0FBYztZQUFFLE9BQU8sUUFBUSxDQUFDO1FBQzNELElBQU0sZUFBZSxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsYUFBYSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzVELElBQU0sY0FBYyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUMzRixJQUFJLGNBQWMsQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzdDLGVBQWUsQ0FB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Z0IsQ0FBQyxRQUFRLEVBQUUsT0FBTyxFQUFFLEVBQUUsQ0FBQyxZQUFZLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQy9FLE9BQU8sSUFBSSxZQUFZLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ2hELENBQUM7SUFKRCxnQ0FJQztJQUVELDZDQUNJLElBQXNCLEVBQUUsZUFBZ0MsRUFBRSxRQUFnQixFQUMxRSxPQUFlO1FBQ2pCLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxJQUFJLG9CQUFhLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDL0MsT0FBTyxPQUFPLENBQUM7U0FDaEI7UUFDSyxJQUFBLHdDQUFpRSxFQUFoRSxrQkFBTSxFQUFFLHdDQUFpQixDQUF3QztRQUV4RSxJQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQ3ZELGVBQWUsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLFVBQVUsQ0FBQyxDQUFDOztZQUNoRCxLQUF5QixJQUFBLHNCQUFBLFNBQUEsaUJBQWlCLENBQUEsb0RBQUE7Z0JBQXJDLElBQU0sVUFBVSw4QkFBQTtnQkFDbkIsZUFBZSxDQUFDLG1CQUFtQixDQUFDLFFBQVEsRUFBRSxVQUFVLENBQUMsQ0FBQzthQUMzRDs7Ozs7Ozs7O1FBRUQsT0FBTyxNQUFNLENBQUM7O0lBQ2hCLENBQUM7SUFmRCxrRkFlQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IHtpc0Nsb3N1cmVGaWxlb3ZlcnZpZXdDb21tZW50fSBmcm9tICcuL2ZpbGVvdmVydmlld19jb21tZW50X3RyYW5zZm9ybWVyJztcbmltcG9ydCB7TW9kdWxlc01hbmlmZXN0fSBmcm9tICcuL21vZHVsZXNfbWFuaWZlc3QnO1xuaW1wb3J0IHtnZXRJZGVudGlmaWVyVGV4dCwgUmV3cml0ZXJ9IGZyb20gJy4vcmV3cml0ZXInO1xuaW1wb3J0ICogYXMgdHMgZnJvbSAnLi90eXBlc2NyaXB0JztcbmltcG9ydCB7aXNEdHNGaWxlTmFtZX0gZnJvbSAnLi91dGlsJztcblxuLy8gTWF0Y2hlcyBjb21tb24gZXh0ZW5zaW9ucyBvZiBUeXBlU2NyaXB0IGlucHV0IGZpbGVuYW1lc1xuY29uc3QgVFNfRVhURU5TSU9OUyA9IC8oXFwudHN8XFwuZFxcLnRzfFxcLmpzfFxcLmpzeHxcXC50c3gpJC87XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXM1UHJvY2Vzc29ySG9zdCB7XG4gIC8qKlxuICAgKiBUYWtlcyBhIGNvbnRleHQgKHRoZSBjdXJyZW50IGZpbGUpIGFuZCB0aGUgcGF0aCBvZiB0aGUgZmlsZSB0byBpbXBvcnRcbiAgICogIGFuZCBnZW5lcmF0ZXMgYSBnb29nbW9kdWxlIG1vZHVsZSBuYW1lXG4gICAqL1xuICBwYXRoVG9Nb2R1bGVOYW1lKGNvbnRleHQ6IHN0cmluZywgaW1wb3J0UGF0aDogc3RyaW5nKTogc3RyaW5nO1xuICAvKipcbiAgICogSWYgd2UgZG8gZ29vZ21vZHVsZSBwcm9jZXNzaW5nLCB3ZSBwb2x5ZmlsbCBtb2R1bGUuaWQsIHNpbmNlIHRoYXQnc1xuICAgKiBwYXJ0IG9mIEVTNiBtb2R1bGVzLiAgVGhpcyBmdW5jdGlvbiBkZXRlcm1pbmVzIHdoYXQgdGhlIG1vZHVsZS5pZCB3aWxsIGJlXG4gICAqIGZvciBlYWNoIGZpbGUuXG4gICAqL1xuICBmaWxlTmFtZVRvTW9kdWxlSWQoZmlsZU5hbWU6IHN0cmluZyk6IHN0cmluZztcbiAgLyoqIFdoZXRoZXIgdG8gY29udmVydCBDb21tb25KUyBtb2R1bGUgc3ludGF4IHRvIGBnb29nLm1vZHVsZWAgQ2xvc3VyZSBpbXBvcnRzLiAqL1xuICBnb29nbW9kdWxlPzogYm9vbGVhbjtcbiAgLyoqIElkZW50aWZpZXMgd2hldGhlciB0aGlzIGZpbGUgaXMgdGhlIHJlc3VsdCBvZiBhIEpTIHRyYW5zcGlsYXRpb24uICovXG4gIGlzSnNUcmFuc3BpbGF0aW9uPzogYm9vbGVhbjtcbiAgLyoqIFdoZXRoZXIgdGhlIGVtaXQgdGFyZ2V0cyBFUzUgb3IgRVM2Ky4gKi9cbiAgZXM1TW9kZT86IGJvb2xlYW47XG4gIC8qKiBleHBhbmQgXCJpbXBvcnQgJ2Zvbyc7XCIgdG8gXCJpbXBvcnQgJ2Zvby9pbmRleCc7XCIgaWYgaXQgcG9pbnRzIHRvIGFuIGluZGV4IGZpbGUuICovXG4gIGNvbnZlcnRJbmRleEltcG9ydFNob3J0aGFuZD86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBBbiBhZGRpdGlvbmFsIHByZWx1ZGUgdG8gaW5zZXJ0IGluIGZyb250IG9mIHRoZSBlbWl0dGVkIGNvZGUsIGUuZy4gdG8gaW1wb3J0IGEgc2hhcmVkIGxpYnJhcnkuXG4gICAqL1xuICBwcmVsdWRlPzogc3RyaW5nO1xuXG4gIG9wdGlvbnM6IHRzLkNvbXBpbGVyT3B0aW9ucztcbiAgaG9zdDogdHMuTW9kdWxlUmVzb2x1dGlvbkhvc3Q7XG59XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIG5hbWVzcGFjZSBwYXJ0IG9mIGEgZ29vZzogaW1wb3J0LCBvciByZXR1cm5zIG51bGwgaWYgdGhlIGdpdmVuXG4gKiBpbXBvcnQgaXMgbm90IGEgZ29vZzogaW1wb3J0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdEdvb2dOYW1lc3BhY2VJbXBvcnQodHNJbXBvcnQ6IHN0cmluZyk6IHN0cmluZ3xudWxsIHtcbiAgaWYgKHRzSW1wb3J0Lm1hdGNoKC9eZ29vZzovKSkgcmV0dXJuIHRzSW1wb3J0LnN1YnN0cmluZygnZ29vZzonLmxlbmd0aCk7XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENvbnZlcnQgZnJvbSBpbXBsaWNpdCBgaW1wb3J0IHt9IGZyb20gJ3BrZydgIHRvIGBpbXBvcnQge30gZnJvbSAncGtnL2luZGV4Jy5cbiAqIFR5cGVTY3JpcHQgc3VwcG9ydHMgdGhlIHNob3J0aGFuZCwgYnV0IG5vdCBhbGwgRVM2IG1vZHVsZSBsb2FkZXJzIGRvLlxuICogV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xMjU5N1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUluZGV4U2hvcnRoYW5kKFxuICAgIGhvc3Q6IHtvcHRpb25zOiB0cy5Db21waWxlck9wdGlvbnMsIGhvc3Q6IHRzLk1vZHVsZVJlc29sdXRpb25Ib3N0fSwgZmlsZU5hbWU6IHN0cmluZyxcbiAgICBpbXBvcnRlZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgcmVzb2x2ZWQgPSB0cy5yZXNvbHZlTW9kdWxlTmFtZShpbXBvcnRlZCwgZmlsZU5hbWUsIGhvc3Qub3B0aW9ucywgaG9zdC5ob3N0KTtcbiAgaWYgKCFyZXNvbHZlZCB8fCAhcmVzb2x2ZWQucmVzb2x2ZWRNb2R1bGUpIHJldHVybiBpbXBvcnRlZDtcbiAgY29uc3QgcmVxdWVzdGVkTW9kdWxlID0gaW1wb3J0ZWQucmVwbGFjZShUU19FWFRFTlNJT05TLCAnJyk7XG4gIGNvbnN0IHJlc29sdmVkTW9kdWxlID0gcmVzb2x2ZWQucmVzb2x2ZWRNb2R1bGUucmVzb2x2ZWRGaWxlTmFtZS5yZXBsYWNlKFRTX0VYVEVOU0lPTlMsICcnKTtcbiAgaWYgKHJlc29sdmVkTW9kdWxlLmluZGV4T2YoJ25vZGVfbW9kdWxlcycpID09PSAtMSAmJlxuICAgICAgcmVxdWVzdGVkTW9kdWxlLnN1YnN0cihyZXF1ZXN0ZWRNb2R1bGUubGFzdEluZGV4T2YoJy8nKSkgIT09XG4gICAgICAgICAgcmVzb2x2ZWRNb2R1bGUuc3Vic3RyKHJlc29sdmVkTW9kdWxlLmxhc3RJbmRleE9mKCcvJykpKSB7XG4gICAgaW1wb3J0ZWQgPSAnLi8nICsgcGF0aC5yZWxhdGl2ZShwYXRoLmRpcm5hbWUoZmlsZU5hbWUpLCByZXNvbHZlZE1vZHVsZSkucmVwbGFjZShwYXRoLnNlcCwgJy8nKTtcbiAgfVxuICByZXR1cm4gaW1wb3J0ZWQ7XG59XG5cbi8qKlxuICogRVM1UHJvY2Vzc29yIHBvc3Rwcm9jZXNzZXMgdGhlIGNvbXBpbGF0aW9uIG91dHB1dCBmcm9tIFRTQy4gSXQgcmV3cml0ZXMgY29tbW9uanMgcmVxdWlyZSgpc1xuICogaW50byBnb29nLnJlcXVpcmUoKS4gQ29udHJhcnkgdG8gaXRzIG5hbWUgaXQgaGFuZGxlcyBjb252ZXJ0aW5nIHRoZSBtb2R1bGVzIGluIGJvdGggRVM1XG4gKiBhbmQgRVM2IG91dHB1dHMuXG4gKi9cbmNsYXNzIEVTNVByb2Nlc3NvciBleHRlbmRzIFJld3JpdGVyIHtcbiAgLyoqXG4gICAqIG5hbWVzcGFjZUltcG9ydHMgY29sbGVjdHMgdGhlIHZhcmlhYmxlcyBmb3IgaW1wb3J0ZWQgZ29vZy5tb2R1bGVzLlxuICAgKiBJZiB0aGUgb3JpZ2luYWwgVFMgaW5wdXQgaXM6XG4gICAqICAgaW1wb3J0IGZvbyBmcm9tICdnb29nOmJhcic7XG4gICAqIHRoZW4gVFMgcHJvZHVjZXM6XG4gICAqICAgdmFyIGZvbyA9IHJlcXVpcmUoJ2dvb2c6YmFyJyk7XG4gICAqIGFuZCB0aGlzIGNsYXNzIHJld3JpdGVzIGl0IHRvOlxuICAgKiAgIHZhciBmb28gPSByZXF1aXJlKCdnb29nLmJhcicpO1xuICAgKiBBZnRlciB0aGlzIHN0ZXAsIG5hbWVzcGFjZUltcG9ydHNbJ2ZvbyddIGlzIHRydWUuXG4gICAqIChUaGlzIGlzIHVzZWQgdG8gcmV3cml0ZSAnZm9vLmRlZmF1bHQnIGludG8ganVzdCAnZm9vJy4pXG4gICAqL1xuICBuYW1lc3BhY2VJbXBvcnRzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgLyoqXG4gICAqIG1vZHVsZVZhcmlhYmxlcyBtYXBzIGZyb20gbW9kdWxlIG5hbWVzIHRvIHRoZSB2YXJpYWJsZXMgdGhleSdyZSBhc3NpZ25lZCB0by5cbiAgICogQ29udGludWluZyB0aGUgYWJvdmUgZXhhbXBsZSwgbW9kdWxlVmFyaWFibGVzWydnb29nLmJhciddID0gJ2ZvbycuXG4gICAqL1xuICBtb2R1bGVWYXJpYWJsZXMgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpO1xuXG4gIC8qKiBzdHJpcHBlZFN0cmljdCBpcyB0cnVlIG9uY2Ugd2UndmUgc3RyaXBwZWQgYSBcInVzZSBzdHJpY3RcIjsgZnJvbSB0aGUgaW5wdXQuICovXG4gIHN0cmlwcGVkU3RyaWN0ID0gZmFsc2U7XG5cbiAgLyoqIHVudXNlZEluZGV4IGlzIHVzZWQgdG8gZ2VuZXJhdGUgZnJlc2ggc3ltYm9scyBmb3IgdW5uYW1lZCBpbXBvcnRzLiAqL1xuICB1bnVzZWRJbmRleCA9IDA7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBob3N0OiBFczVQcm9jZXNzb3JIb3N0LCBmaWxlOiB0cy5Tb3VyY2VGaWxlKSB7XG4gICAgc3VwZXIoZmlsZSk7XG4gIH1cblxuICBwcm9jZXNzKCk6IHtvdXRwdXQ6IHN0cmluZywgcmVmZXJlbmNlZE1vZHVsZXM6IHN0cmluZ1tdfSB7XG4gICAgdGhpcy5lbWl0RmlsZUNvbW1lbnQoKTtcblxuICAgIGNvbnN0IG1vZHVsZUlkID0gdGhpcy5ob3N0LmZpbGVOYW1lVG9Nb2R1bGVJZCh0aGlzLmZpbGUuZmlsZU5hbWUpO1xuICAgIC8vIFRoZSBnb29nLm1vZHVsZSgpIGNhbGwgc2hvdWxkIG5vdCBiZSBlbWl0dGVkIGlmIHRoZSBmaWxlIGlzIHRoZSByZXN1bHRcbiAgICAvLyBvZiB0cmFuc3BpbGluZyBKUyBzb3VyY2VzLiBFbWl0dGluZyBnb29nLm1vZHVsZSgpIHdvdWxkIGNoYW5nZSB0aGUgc2VtYW50aWNzXG4gICAgLy8gb2YgdGhlIGZpbGUuXG4gICAgaWYgKCF0aGlzLmhvc3QuaXNKc1RyYW5zcGlsYXRpb24pIHtcbiAgICAgIGNvbnN0IG1vZHVsZU5hbWUgPSB0aGlzLmhvc3QucGF0aFRvTW9kdWxlTmFtZSgnJywgdGhpcy5maWxlLmZpbGVOYW1lKTtcbiAgICAgIC8vIE5COiBObyBsaW5lYnJlYWsgYWZ0ZXIgbW9kdWxlIGNhbGwgc28gc291cmNlbWFwcyBhcmUgbm90IG9mZnNldC5cbiAgICAgIHRoaXMuZW1pdChgZ29vZy5tb2R1bGUoJyR7bW9kdWxlTmFtZX0nKTtgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaG9zdC5wcmVsdWRlKSB0aGlzLmVtaXQodGhpcy5ob3N0LnByZWx1ZGUpO1xuICAgIC8vIEFsbG93IGNvZGUgdG8gdXNlIGBtb2R1bGUuaWRgIHRvIGRpc2NvdmVyIGl0cyBtb2R1bGUgVVJMLCBlLmcuIHRvIHJlc29sdmVcbiAgICAvLyBhIHRlbXBsYXRlIFVSTCBhZ2FpbnN0LlxuICAgIC8vIFVzZXMgJ3ZhcicsIGFzIHRoaXMgY29kZSBpcyBpbnNlcnRlZCBpbiBFUzYgYW5kIEVTNSBtb2Rlcy5cbiAgICAvLyBUaGUgZm9sbG93aW5nIHBhdHRlcm4gZW5zdXJlcyBjbG9zdXJlIGRvZXNuJ3QgdGhyb3cgYW4gZXJyb3IgaW4gYWR2YW5jZWRcbiAgICAvLyBvcHRpbWl6YXRpb25zIG1vZGUuXG4gICAgaWYgKHRoaXMuaG9zdC5lczVNb2RlKSB7XG4gICAgICBpZiAoIXRoaXMuaG9zdC5pc0pzVHJhbnNwaWxhdGlvbikge1xuICAgICAgICB0aGlzLmVtaXQoYHZhciBtb2R1bGUgPSBtb2R1bGUgfHwge2lkOiAnJHttb2R1bGVJZH0nfTtgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIGBleHBvcnRzID0ge31gIHNlcnZlcyBhcyBhIGRlZmF1bHQgZXhwb3J0IHRvIGRpc2FibGUgQ2xvc3VyZSBDb21waWxlcidzIGVycm9yIGNoZWNraW5nXG4gICAgICAvLyBmb3IgbXV0YWJsZSBleHBvcnRzLiBUaGF0J3MgT0sgYmVjYXVzZSBUUyBjb21waWxlciBtYWtlcyBzdXJlIHRoYXQgY29uc3VtaW5nIGNvZGUgYWx3YXlzXG4gICAgICAvLyBhY2Nlc3NlcyBleHBvcnRzIHRocm91Z2ggdGhlIG1vZHVsZSBvYmplY3QsIHNvIG11dGFibGUgZXhwb3J0cyB3b3JrLlxuICAgICAgLy8gSXQgaXMgb25seSBpbnNlcnRlZCBpbiBFUzYgYmVjYXVzZSB3ZSBzdHJpcCBgLmRlZmF1bHRgIGFjY2Vzc2VzIGluIEVTNSBtb2RlLCB3aGljaCBicmVha3NcbiAgICAgIC8vIHdoZW4gYXNzaWduaW5nIGFuIGBleHBvcnRzID0ge31gIG9iamVjdCBhbmQgdGhlbiBsYXRlciBhY2Nlc3NpbmcgaXQuXG4gICAgICAvLyBIb3dldmVyIENsb3N1cmUgYmFpbHMgaWYgY29kZSBsYXRlciBvbiBhc3NpZ25zIGludG8gZXhwb3J0cyBkaXJlY3RseSwgYXMgd2UgZG8gaWYgd2UgaGF2ZVxuICAgICAgLy8gYW4gXCJleHBvcnRzID0gXCIgYmxvY2ssIHNvIHNraXAgZW1pdCBpZiB0aGF0J3MgdGhlIGNhc2UuXG4gICAgICBpZiAoIXRoaXMuZmlsZS5zdGF0ZW1lbnRzLmZpbmQoXG4gICAgICAgICAgICAgIHMgPT4gdHMuaXNFeHByZXNzaW9uU3RhdGVtZW50KHMpICYmIHRoaXMuaXNNb2R1bGVFeHBvcnRzQXNzaWdubWVudChzKSkpIHtcbiAgICAgICAgdGhpcy5lbWl0KGAgZXhwb3J0cyA9IHt9O2ApO1xuICAgICAgfVxuICAgICAgLy8gVGhlIG1vZHVsZT1tb2R1bGUgYml0IHN1cHByZXNzZXMgYW4gdW51c2VkIHZhcmlhYmxlIHdhcm5pbmcgd2hpY2hcbiAgICAgIC8vIG1heSB0cmlnZ2VyIGRlcGVuZGluZyBvbiB0aGUgY29tcGlsYXRpb24gZmxhZ3MuXG4gICAgICB0aGlzLmVtaXQoYCB2YXIgbW9kdWxlID0gbW9kdWxlIHx8IHtpZDogJyR7bW9kdWxlSWR9J307IG1vZHVsZSA9IG1vZHVsZTtgKTtcbiAgICB9XG5cbiAgICBsZXQgcG9zID0gMDtcbiAgICBmb3IgKGNvbnN0IHN0bXQgb2YgdGhpcy5maWxlLnN0YXRlbWVudHMpIHtcbiAgICAgIHRoaXMud3JpdGVSYW5nZSh0aGlzLmZpbGUsIHBvcywgc3RtdC5nZXRGdWxsU3RhcnQoKSk7XG4gICAgICB0aGlzLnZpc2l0VG9wTGV2ZWwoc3RtdCk7XG4gICAgICBwb3MgPSBzdG10LmdldEVuZCgpO1xuICAgIH1cbiAgICB0aGlzLndyaXRlUmFuZ2UodGhpcy5maWxlLCBwb3MsIHRoaXMuZmlsZS5nZXRFbmQoKSk7XG5cbiAgICBjb25zdCByZWZlcmVuY2VkTW9kdWxlcyA9IEFycmF5LmZyb20odGhpcy5tb2R1bGVWYXJpYWJsZXMua2V5cygpKTtcbiAgICAvLyBOb3RlOiBkb24ndCBzb3J0IHJlZmVyZW5jZWRNb2R1bGVzLCBhcyB0aGUga2V5cyBhcmUgaW4gdGhlIHNhbWUgb3JkZXJcbiAgICAvLyB0aGV5IG9jY3VyIGluIHRoZSBzb3VyY2UgZmlsZS5cbiAgICBjb25zdCB7b3V0cHV0fSA9IHRoaXMuZ2V0T3V0cHV0KCk7XG4gICAgcmV0dXJuIHtvdXRwdXQsIHJlZmVyZW5jZWRNb2R1bGVzfTtcbiAgfVxuXG4gIC8qKiBFbWl0cyBmaWxlIGNvbW1lbnRzIGZvciB0aGUgY3VycmVudCBzb3VyY2UgZmlsZSwgaWYgYW55LiAqL1xuICBwcml2YXRlIGVtaXRGaWxlQ29tbWVudCgpIHtcbiAgICBjb25zdCBsZWFkaW5nQ29tbWVudHMgPSB0cy5nZXRMZWFkaW5nQ29tbWVudFJhbmdlcyh0aGlzLmZpbGUuZ2V0RnVsbFRleHQoKSwgMCkgfHwgW107XG4gICAgY29uc3QgZmlsZUNvbW1lbnQgPSBsZWFkaW5nQ29tbWVudHMuZmluZChjID0+IHtcbiAgICAgIGlmIChjLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuTXVsdGlMaW5lQ29tbWVudFRyaXZpYSkgcmV0dXJuIGZhbHNlO1xuICAgICAgY29uc3QgY29tbWVudFRleHQgPSB0aGlzLmZpbGUuZ2V0RnVsbFRleHQoKS5zdWJzdHJpbmcoYy5wb3MsIGMuZW5kKTtcbiAgICAgIHJldHVybiBpc0Nsb3N1cmVGaWxlb3ZlcnZpZXdDb21tZW50KGNvbW1lbnRUZXh0KTtcbiAgICB9KTtcbiAgICBpZiAoIWZpbGVDb21tZW50KSByZXR1cm47XG4gICAgbGV0IGVuZCA9IGZpbGVDb21tZW50LmVuZDtcbiAgICBpZiAoZmlsZUNvbW1lbnQuaGFzVHJhaWxpbmdOZXdMaW5lKSBlbmQrKztcbiAgICB0aGlzLndyaXRlTGVhZGluZ1RyaXZpYSh0aGlzLmZpbGUsIGVuZCk7XG4gIH1cblxuICAvKipcbiAgICogdmlzaXRUb3BMZXZlbCBwcm9jZXNzZXMgYSB0b3AtbGV2ZWwgdHMuTm9kZSBhbmQgZW1pdHMgaXRzIGNvbnRlbnRzLlxuICAgKlxuICAgKiBJdCdzIHNlcGFyYXRlIGZyb20gdGhlIG5vcm1hbCBSZXdyaXRlciByZWN1cnNpdmUgdHJhdmVyc2FsXG4gICAqIGJlY2F1c2Ugc29tZSB0b3AtbGV2ZWwgc3RhdGVtZW50cyBhcmUgaGFuZGxlZCBzcGVjaWFsbHkuXG4gICAqL1xuICB2aXNpdFRvcExldmVsKG5vZGU6IHRzLk5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUua2luZCkge1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkV4cHJlc3Npb25TdGF0ZW1lbnQ6XG4gICAgICAgIGNvbnN0IGV4cHJTdGF0ZW1lbnQgPSBub2RlIGFzIHRzLkV4cHJlc3Npb25TdGF0ZW1lbnQ7XG4gICAgICAgIC8vIENoZWNrIGZvciBcInVzZSBzdHJpY3RcIiBhbmQgc2tpcCBpdCBpZiBuZWNlc3NhcnkuXG4gICAgICAgIGlmICghdGhpcy5zdHJpcHBlZFN0cmljdCAmJiB0aGlzLmlzVXNlU3RyaWN0KG5vZGUpKSB7XG4gICAgICAgICAgdGhpcy5lbWl0Q29tbWVudFdpdGhvdXRTdGF0ZW1lbnRCb2R5KG5vZGUpO1xuICAgICAgICAgIHRoaXMuc3RyaXBwZWRTdHJpY3QgPSB0cnVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBmb3I6XG4gICAgICAgIC8vIC0gXCJyZXF1aXJlKCdmb28nKTtcIiAoYSByZXF1aXJlIGZvciBpdHMgc2lkZSBlZmZlY3RzKVxuICAgICAgICAvLyAtIFwiX19leHBvcnQocmVxdWlyZSguLi4pKTtcIiAoYW4gXCJleHBvcnQgKiBmcm9tIC4uLlwiKVxuICAgICAgICBpZiAodGhpcy5lbWl0UmV3cml0dGVuUmVxdWlyZXMobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yXG4gICAgICAgIC8vICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAuLi4pO1xuICAgICAgICBpZiAodGhpcy5pc0VzTW9kdWxlUHJvcGVydHkoZXhwclN0YXRlbWVudCkpIHtcbiAgICAgICAgICB0aGlzLmVtaXRDb21tZW50V2l0aG91dFN0YXRlbWVudEJvZHkobm9kZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvclxuICAgICAgICAvLyAgIG1vZHVsZS5leHBvcnRzID0gLi4uO1xuICAgICAgICAvLyBSZXdyaXRlIHRvIGdvb2cubW9kdWxlJ3NcbiAgICAgICAgLy8gICBleHBvcnRzID0gLi4uO1xuICAgICAgICBpZiAodGhpcy5pc01vZHVsZUV4cG9ydHNBc3NpZ25tZW50KGV4cHJTdGF0ZW1lbnQpKSB7XG4gICAgICAgICAgdGhpcy5lbWl0RXhwb3J0c0Fzc2lnbm1lbnQoZXhwclN0YXRlbWVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSBmYWxsIHRocm91Z2ggdG8gZGVmYXVsdCBwcm9jZXNzaW5nLlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5WYXJpYWJsZVN0YXRlbWVudDpcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGEgXCJ2YXIgeCA9IHJlcXVpcmUoJ2ZvbycpO1wiLlxuICAgICAgICBpZiAodGhpcy5lbWl0UmV3cml0dGVuUmVxdWlyZXMobm9kZSkpIHJldHVybjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy52aXNpdChub2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgVHlwZVNjcmlwdCBBU1QgYXR0YWNoZXMgY29tbWVudHMgdG8gc3RhdGVtZW50IG5vZGVzLCBzbyBldmVuIGlmIGEgbm9kZVxuICAgKiBjb250YWlucyBjb2RlIHdlIHdhbnQgdG8gc2tpcCBlbWl0dGluZywgd2UgbmVlZCB0byBlbWl0IHRoZSBhdHRhY2hlZFxuICAgKiBjb21tZW50KHMpLlxuICAgKi9cbiAgZW1pdENvbW1lbnRXaXRob3V0U3RhdGVtZW50Qm9keShub2RlOiB0cy5Ob2RlKSB7XG4gICAgdGhpcy53cml0ZUxlYWRpbmdUcml2aWEobm9kZSk7XG4gIH1cblxuICAvKiogaXNVc2VTdHJpY3QgcmV0dXJucyB0cnVlIGlmIG5vZGUgaXMgYSBcInVzZSBzdHJpY3RcIjsgc3RhdGVtZW50LiAqL1xuICBpc1VzZVN0cmljdChub2RlOiB0cy5Ob2RlKTogYm9vbGVhbiB7XG4gICAgaWYgKG5vZGUua2luZCAhPT0gdHMuU3ludGF4S2luZC5FeHByZXNzaW9uU3RhdGVtZW50KSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgZXhwclN0bXQgPSBub2RlIGFzIHRzLkV4cHJlc3Npb25TdGF0ZW1lbnQ7XG4gICAgY29uc3QgZXhwciA9IGV4cHJTdG10LmV4cHJlc3Npb247XG4gICAgaWYgKGV4cHIua2luZCAhPT0gdHMuU3ludGF4S2luZC5TdHJpbmdMaXRlcmFsKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgbGl0ZXJhbCA9IGV4cHIgYXMgdHMuU3RyaW5nTGl0ZXJhbDtcbiAgICByZXR1cm4gbGl0ZXJhbC50ZXh0ID09PSAndXNlIHN0cmljdCc7XG4gIH1cblxuICAvKipcbiAgICogZW1pdFJld3JpdHRlblJlcXVpcmVzIHJld3JpdGVzIHJlcXVpcmUoKXMgaW50byBnb29nLnJlcXVpcmUoKSBlcXVpdmFsZW50cy5cbiAgICpcbiAgICogQHJldHVybiBUcnVlIGlmIHRoZSBub2RlIHdhcyByZXdyaXR0ZW4sIGZhbHNlIGlmIG5lZWRzIG9yZGluYXJ5IHByb2Nlc3NpbmcuXG4gICAqL1xuICBlbWl0UmV3cml0dGVuUmVxdWlyZXMobm9kZTogdHMuTm9kZSk6IGJvb2xlYW4ge1xuICAgIC8vIFdlJ3JlIGxvb2tpbmcgZm9yIHJlcXVpcmVzLCBvZiBvbmUgb2YgdGhlIGZvcm1zOlxuICAgIC8vIC0gXCJ2YXIgaW1wb3J0TmFtZSA9IHJlcXVpcmUoLi4uKTtcIi5cbiAgICAvLyAtIFwicmVxdWlyZSguLi4pO1wiLlxuICAgIGlmIChub2RlLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuVmFyaWFibGVTdGF0ZW1lbnQpIHtcbiAgICAgIC8vIEl0J3MgcG9zc2libHkgb2YgdGhlIGZvcm0gXCJ2YXIgeCA9IHJlcXVpcmUoLi4uKTtcIi5cbiAgICAgIGNvbnN0IHZhclN0bXQgPSBub2RlIGFzIHRzLlZhcmlhYmxlU3RhdGVtZW50O1xuXG4gICAgICAvLyBWZXJpZnkgaXQncyBhIHNpbmdsZSBkZWNsIChhbmQgbm90IFwidmFyIHggPSAuLi4sIHkgPSAuLi47XCIpLlxuICAgICAgaWYgKHZhclN0bXQuZGVjbGFyYXRpb25MaXN0LmRlY2xhcmF0aW9ucy5sZW5ndGggIT09IDEpIHJldHVybiBmYWxzZTtcbiAgICAgIGNvbnN0IGRlY2wgPSB2YXJTdG10LmRlY2xhcmF0aW9uTGlzdC5kZWNsYXJhdGlvbnNbMF07XG5cbiAgICAgIC8vIEdyYWIgdGhlIHZhcmlhYmxlIG5hbWUgKGF2b2lkaW5nIHRoaW5ncyBsaWtlIGRlc3RydWN0dXJpbmcgYmluZHMpLlxuICAgICAgaWYgKGRlY2wubmFtZS5raW5kICE9PSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXIpIHJldHVybiBmYWxzZTtcbiAgICAgIGNvbnN0IHZhck5hbWUgPSBnZXRJZGVudGlmaWVyVGV4dChkZWNsLm5hbWUgYXMgdHMuSWRlbnRpZmllcik7XG4gICAgICBpZiAoIWRlY2wuaW5pdGlhbGl6ZXIgfHwgZGVjbC5pbml0aWFsaXplci5raW5kICE9PSB0cy5TeW50YXhLaW5kLkNhbGxFeHByZXNzaW9uKSByZXR1cm4gZmFsc2U7XG4gICAgICBjb25zdCBjYWxsID0gZGVjbC5pbml0aWFsaXplciBhcyB0cy5DYWxsRXhwcmVzc2lvbjtcbiAgICAgIGNvbnN0IHJlcXVpcmUgPSB0aGlzLmV4dHJhY3RSZXF1aXJlKGNhbGwpO1xuICAgICAgaWYgKCFyZXF1aXJlKSByZXR1cm4gZmFsc2U7XG4gICAgICAvLyBJbiBKUyB0cmFuc3BpbGF0aW9uLCB0aGUgb25seSByZXF1aXJlKCcuLi4nKSB0aGF0IG5lZWRzIHRvIGJlXG4gICAgICAvLyByZXdyaXR0ZW4gaXMgcmVxdWlyZSgndHNsaWInKSwgd2hpY2ggaXMgZW1pdHRlZCBieSBUU0Mgd2hlbiBsb2FkaW5nXG4gICAgICAvLyBFUzYgcG9seWZpbGxzLlxuICAgICAgaWYgKHRoaXMuaG9zdC5pc0pzVHJhbnNwaWxhdGlvbiAmJiByZXF1aXJlICE9PSAndHNsaWInKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aGlzLndyaXRlTGVhZGluZ1RyaXZpYShub2RlKTtcbiAgICAgIHRoaXMuZW1pdEdvb2dSZXF1aXJlKHZhck5hbWUsIHJlcXVpcmUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChub2RlLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuRXhwcmVzc2lvblN0YXRlbWVudCkge1xuICAgICAgLy8gSXQncyBwb3NzaWJseSBvZiB0aGUgZm9ybTpcbiAgICAgIC8vIC0gcmVxdWlyZSguLi4pO1xuICAgICAgLy8gLSBfX2V4cG9ydChyZXF1aXJlKC4uLikpO1xuICAgICAgLy8gLSB0c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKC4uLikpO1xuICAgICAgLy8gQWxsIGFyZSBDYWxsRXhwcmVzc2lvbnMuXG4gICAgICBjb25zdCBleHByU3RtdCA9IG5vZGUgYXMgdHMuRXhwcmVzc2lvblN0YXRlbWVudDtcbiAgICAgIGNvbnN0IGV4cHIgPSBleHByU3RtdC5leHByZXNzaW9uO1xuICAgICAgaWYgKGV4cHIua2luZCAhPT0gdHMuU3ludGF4S2luZC5DYWxsRXhwcmVzc2lvbikgcmV0dXJuIGZhbHNlO1xuICAgICAgbGV0IGNhbGwgPSBleHByIGFzIHRzLkNhbGxFeHByZXNzaW9uO1xuXG4gICAgICBsZXQgcmVxdWlyZSA9IHRoaXMuZXh0cmFjdFJlcXVpcmUoY2FsbCk7XG4gICAgICBsZXQgaXNFeHBvcnQgPSBmYWxzZTtcbiAgICAgIGlmICghcmVxdWlyZSkge1xuICAgICAgICAvLyBJZiBpdCdzIGFuIF9fZXhwb3J0KHJlcXVpcmUoLi4uKSksIHdlIGVtaXQ6XG4gICAgICAgIC8vICAgdmFyIHggPSByZXF1aXJlKC4uLik7XG4gICAgICAgIC8vICAgX19leHBvcnQoeCk7XG4gICAgICAgIC8vIFRoaXMgZXh0cmEgdmFyaWFibGUgaXMgbmVjZXNzYXJ5IGluIGNhc2UgdGhlcmUncyBhIGxhdGVyIGltcG9ydCBvZiB0aGVcbiAgICAgICAgLy8gc2FtZSBtb2R1bGUgbmFtZS5cbiAgICAgICAgY29uc3QgaW5uZXJDYWxsID0gdGhpcy5pc0V4cG9ydFJlcXVpcmUoY2FsbCk7XG4gICAgICAgIGlmICghaW5uZXJDYWxsKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlzRXhwb3J0ID0gdHJ1ZTtcbiAgICAgICAgY2FsbCA9IGlubmVyQ2FsbDsgIC8vIFVwZGF0ZSBjYWxsIHRvIHBvaW50IGF0IHRoZSByZXF1aXJlKCkgZXhwcmVzc2lvbi5cbiAgICAgICAgcmVxdWlyZSA9IHRoaXMuZXh0cmFjdFJlcXVpcmUoY2FsbCk7XG4gICAgICB9XG4gICAgICBpZiAoIXJlcXVpcmUpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gSW4gSlMgdHJhbnNwaWxhdGlvbiwgdGhlIG9ubHkgcmVxdWlyZSgnLi4uJykgdGhhdCBuZWVkcyB0byBiZVxuICAgICAgLy8gcmV3cml0dGVuIGlzIHJlcXVpcmUoJ3RzbGliJyksIHdoaWNoIGlzIGVtaXR0ZWQgYnkgVFNDIHdoZW4gbG9hZGluZ1xuICAgICAgLy8gRVM2IHBvbHlmaWxscy5cbiAgICAgIGlmICh0aGlzLmhvc3QuaXNKc1RyYW5zcGlsYXRpb24gJiYgcmVxdWlyZSAhPT0gJ3RzbGliJykgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhpcy53cml0ZUxlYWRpbmdUcml2aWEobm9kZSk7XG4gICAgICBjb25zdCB2YXJOYW1lID0gdGhpcy5lbWl0R29vZ1JlcXVpcmUobnVsbCwgcmVxdWlyZSk7XG5cbiAgICAgIGlmIChpc0V4cG9ydCkge1xuICAgICAgICAvLyBub2RlIGlzIGEgc3RhdGVtZW50IGNvbnRhaW5pbmcgYSByZXF1aXJlKCkgaW4gaXQsIHdoaWxlXG4gICAgICAgIC8vIHJlcXVpcmVDYWxsIGlzIHRoYXQgY2FsbC4gIFdlIHJlcGxhY2UgdGhlIHJlcXVpcmUoKSBjYWxsXG4gICAgICAgIC8vIHdpdGggdGhlIHZhcmlhYmxlIHdlIGVtaXR0ZWQuXG4gICAgICAgIGNvbnN0IGZ1bGxTdGF0ZW1lbnQgPSBub2RlLmdldFRleHQoKTtcbiAgICAgICAgY29uc3QgcmVxdWlyZUNhbGwgPSBjYWxsLmdldFRleHQoKTtcbiAgICAgICAgdGhpcy5lbWl0KGZ1bGxTdGF0ZW1lbnQucmVwbGFjZShyZXF1aXJlQ2FsbCwgdmFyTmFtZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEl0J3Mgc29tZSBvdGhlciB0eXBlIG9mIHN0YXRlbWVudC5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW1pdHMgYSBnb29nLnJlcXVpcmUoKSBzdGF0ZW1lbnQgZm9yIGEgZ2l2ZW4gdmFyaWFibGUgbmFtZSBhbmQgVHlwZVNjcmlwdCBpbXBvcnQuXG4gICAqXG4gICAqIEUuZy4gZnJvbTpcbiAgICogICB2YXIgdmFyTmFtZSA9IHJlcXVpcmUoJ3RzSW1wb3J0Jyk7XG4gICAqIHByb2R1Y2VzOlxuICAgKiAgIHZhciB2YXJOYW1lID0gZ29vZy5yZXF1aXJlKCdnb29nLm1vZHVsZS5uYW1lJyk7XG4gICAqXG4gICAqIElmIHRoZSBpbnB1dCB2YXJOYW1lIGlzIG51bGwsIGdlbmVyYXRlcyBhIG5ldyB2YXJpYWJsZSBuYW1lIGlmIG5lY2Vzc2FyeS5cbiAgICpcbiAgICogQHJldHVybiBUaGUgdmFyaWFibGUgbmFtZSBmb3IgdGhlIGltcG9ydGVkIG1vZHVsZSwgcmV1c2luZyBhIHByZXZpb3VzIGltcG9ydCBpZiBvbmVcbiAgICogICAgaXMgYXZhaWxhYmxlLlxuICAgKi9cbiAgZW1pdEdvb2dSZXF1aXJlKHZhck5hbWU6IHN0cmluZ3xudWxsLCB0c0ltcG9ydDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBsZXQgbW9kTmFtZTogc3RyaW5nO1xuICAgIGxldCBpc05hbWVzcGFjZUltcG9ydCA9IGZhbHNlO1xuICAgIGNvbnN0IG5zSW1wb3J0ID0gZXh0cmFjdEdvb2dOYW1lc3BhY2VJbXBvcnQodHNJbXBvcnQpO1xuICAgIGlmIChuc0ltcG9ydCAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyBhIG5hbWVzcGFjZSBpbXBvcnQsIG9mIHRoZSBmb3JtIFwiZ29vZzpmb28uYmFyXCIuXG4gICAgICAvLyBGaXggaXQgdG8ganVzdCBcImZvby5iYXJcIi5cbiAgICAgIG1vZE5hbWUgPSBuc0ltcG9ydDtcbiAgICAgIGlzTmFtZXNwYWNlSW1wb3J0ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuaG9zdC5jb252ZXJ0SW5kZXhJbXBvcnRTaG9ydGhhbmQpIHtcbiAgICAgICAgdHNJbXBvcnQgPSByZXNvbHZlSW5kZXhTaG9ydGhhbmQodGhpcy5ob3N0LCB0aGlzLmZpbGUuZmlsZU5hbWUsIHRzSW1wb3J0KTtcbiAgICAgIH1cbiAgICAgIG1vZE5hbWUgPSB0aGlzLmhvc3QucGF0aFRvTW9kdWxlTmFtZSh0aGlzLmZpbGUuZmlsZU5hbWUsIHRzSW1wb3J0KTtcbiAgICB9XG5cbiAgICBpZiAoIXZhck5hbWUpIHtcbiAgICAgIGNvbnN0IG12ID0gdGhpcy5tb2R1bGVWYXJpYWJsZXMuZ2V0KG1vZE5hbWUpO1xuICAgICAgaWYgKG12KSB7XG4gICAgICAgIC8vIENhbGxlciBkaWRuJ3QgcmVxdWVzdCBhIHNwZWNpZmljIHZhcmlhYmxlIG5hbWUgYW5kIHdlJ3ZlIGFscmVhZHlcbiAgICAgICAgLy8gaW1wb3J0ZWQgdGhlIG1vZHVsZSwgc28ganVzdCByZXR1cm4gdGhlIG5hbWUgd2UgYWxyZWFkeSBoYXZlIGZvciB0aGlzIG1vZHVsZS5cbiAgICAgICAgcmV0dXJuIG12O1xuICAgICAgfVxuXG4gICAgICAvLyBOb3RlOiB3ZSBhbHdheXMgaW50cm9kdWNlIGEgdmFyaWFibGUgZm9yIGFueSBpbXBvcnQsIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlclxuICAgICAgLy8gdGhlIGNhbGxlciByZXF1ZXN0ZWQgb25lLiAgVGhpcyBhdm9pZHMgYSBDbG9zdXJlIGVycm9yLlxuICAgICAgdmFyTmFtZSA9IHRoaXMuZ2VuZXJhdGVGcmVzaFZhcmlhYmxlTmFtZSgpO1xuICAgIH1cblxuICAgIGlmIChpc05hbWVzcGFjZUltcG9ydCkgdGhpcy5uYW1lc3BhY2VJbXBvcnRzLmFkZCh2YXJOYW1lKTtcbiAgICBpZiAodGhpcy5tb2R1bGVWYXJpYWJsZXMuaGFzKG1vZE5hbWUpKSB7XG4gICAgICB0aGlzLmVtaXQoYHZhciAke3Zhck5hbWV9ID0gJHt0aGlzLm1vZHVsZVZhcmlhYmxlcy5nZXQobW9kTmFtZSl9O2ApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVtaXQoYHZhciAke3Zhck5hbWV9ID0gZ29vZy5yZXF1aXJlKCcke21vZE5hbWV9Jyk7YCk7XG4gICAgICB0aGlzLm1vZHVsZVZhcmlhYmxlcy5zZXQobW9kTmFtZSwgdmFyTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB2YXJOYW1lO1xuICB9XG4gIC8vIHdvcmthcm91bmQgZm9yIHN5bnRheCBoaWdobGlnaHRpbmcgYnVnIGluIFN1YmxpbWU6IGBcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RyaW5nIGFyZ3VtZW50IGlmIGNhbGwgaXMgb2YgdGhlIGZvcm1cbiAgICogICByZXF1aXJlKCdmb28nKVxuICAgKi9cbiAgZXh0cmFjdFJlcXVpcmUoY2FsbDogdHMuQ2FsbEV4cHJlc3Npb24pOiBzdHJpbmd8bnVsbCB7XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNhbGwgaXMgYSBjYWxsIHRvIHJlcXVpcmUoLi4uKS5cbiAgICBpZiAoY2FsbC5leHByZXNzaW9uLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuSWRlbnRpZmllcikgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgaWRlbnQgPSBjYWxsLmV4cHJlc3Npb24gYXMgdHMuSWRlbnRpZmllcjtcbiAgICBpZiAoZ2V0SWRlbnRpZmllclRleHQoaWRlbnQpICE9PSAncmVxdWlyZScpIHJldHVybiBudWxsO1xuXG4gICAgLy8gVmVyaWZ5IHRoZSBjYWxsIHRha2VzIGEgc2luZ2xlIHN0cmluZyBhcmd1bWVudCBhbmQgZ3JhYiBpdC5cbiAgICBpZiAoY2FsbC5hcmd1bWVudHMubGVuZ3RoICE9PSAxKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBhcmcgPSBjYWxsLmFyZ3VtZW50c1swXTtcbiAgICBpZiAoYXJnLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuU3RyaW5nTGl0ZXJhbCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIChhcmcgYXMgdHMuU3RyaW5nTGl0ZXJhbCkudGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXF1aXJlKCkgY2FsbCBub2RlIGlmIHRoZSBvdXRlciBjYWxsIGlzIG9mIHRoZSBmb3JtczpcbiAgICogLSBfX2V4cG9ydChyZXF1aXJlKCdmb28nKSlcbiAgICogLSB0c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKCdmb28nKSwgYmFyKVxuICAgKi9cbiAgaXNFeHBvcnRSZXF1aXJlKGNhbGw6IHRzLkNhbGxFeHByZXNzaW9uKTogdHMuQ2FsbEV4cHJlc3Npb258bnVsbCB7XG4gICAgc3dpdGNoIChjYWxsLmV4cHJlc3Npb24ua2luZCkge1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXI6XG4gICAgICAgIGNvbnN0IGlkZW50ID0gY2FsbC5leHByZXNzaW9uIGFzIHRzLklkZW50aWZpZXI7XG4gICAgICAgIC8vIFRTXzI0X0NPTVBBVDogYWNjZXB0IHRocmVlIGxlYWRpbmcgdW5kZXJzY29yZXNcbiAgICAgICAgaWYgKGlkZW50LnRleHQgIT09ICdfX2V4cG9ydCcgJiYgaWRlbnQudGV4dCAhPT0gJ19fX2V4cG9ydCcpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5Qcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb246XG4gICAgICAgIGNvbnN0IHByb3BBY2Nlc3MgPSBjYWxsLmV4cHJlc3Npb24gYXMgdHMuUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uO1xuICAgICAgICAvLyBUU18yNF9DT01QQVQ6IGFjY2VwdCB0aHJlZSBsZWFkaW5nIHVuZGVyc2NvcmVzXG4gICAgICAgIGlmIChwcm9wQWNjZXNzLm5hbWUudGV4dCAhPT0gJ19fZXhwb3J0U3RhcicgJiYgcHJvcEFjY2Vzcy5uYW1lLnRleHQgIT09ICdfX19leHBvcnRTdGFyJykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gVmVyaWZ5IHRoZSBjYWxsIHRha2VzIGF0IGxlYXN0IG9uZSBhcmd1bWVudCBhbmQgY2hlY2sgaXQuXG4gICAgaWYgKGNhbGwuYXJndW1lbnRzLmxlbmd0aCA8IDEpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGFyZyA9IGNhbGwuYXJndW1lbnRzWzBdO1xuICAgIGlmIChhcmcua2luZCAhPT0gdHMuU3ludGF4S2luZC5DYWxsRXhwcmVzc2lvbikgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgaW5uZXJDYWxsID0gYXJnIGFzIHRzLkNhbGxFeHByZXNzaW9uO1xuICAgIGlmICghdGhpcy5leHRyYWN0UmVxdWlyZShpbm5lckNhbGwpKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gaW5uZXJDYWxsO1xuICB9XG5cbiAgaXNFc01vZHVsZVByb3BlcnR5KGV4cHI6IHRzLkV4cHJlc3Npb25TdGF0ZW1lbnQpOiBib29sZWFuIHtcbiAgICAvLyBXZSdyZSBtYXRjaGluZyB0aGUgZXhwbGljaXQgc291cmNlIHRleHQgZ2VuZXJhdGVkIGJ5IHRoZSBUUyBjb21waWxlci5cbiAgICByZXR1cm4gZXhwci5nZXRUZXh0KCkgPT09ICdPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7JztcbiAgfVxuXG4gIGlzTW9kdWxlRXhwb3J0c0Fzc2lnbm1lbnQoZXhwcjogdHMuRXhwcmVzc2lvblN0YXRlbWVudCk6IGJvb2xlYW4ge1xuICAgIC8vIExvb2tpbmcgZm9yIFwibW9kdWxlLmV4cG9ydHMgPSAuLi47XCJcbiAgICBpZiAoIXRzLmlzQmluYXJ5RXhwcmVzc2lvbihleHByLmV4cHJlc3Npb24pKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGV4cHIuZXhwcmVzc2lvbi5vcGVyYXRvclRva2VuLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuRXF1YWxzVG9rZW4pIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gZXhwci5leHByZXNzaW9uLmxlZnQuZ2V0VGV4dCgpID09PSAnbW9kdWxlLmV4cG9ydHMnO1xuICB9XG5cbiAgZW1pdEV4cG9ydHNBc3NpZ25tZW50KGV4cHI6IHRzLkV4cHJlc3Npb25TdGF0ZW1lbnQpIHtcbiAgICB0aGlzLmVtaXRDb21tZW50V2l0aG91dFN0YXRlbWVudEJvZHkoZXhwcik7XG4gICAgdGhpcy5lbWl0KCdleHBvcnRzID0nKTtcbiAgICB0aGlzLnZpc2l0KChleHByLmV4cHJlc3Npb24gYXMgdHMuQmluYXJ5RXhwcmVzc2lvbikucmlnaHQpO1xuICAgIHRoaXMuZW1pdCgnOycpO1xuICB9XG5cbiAgLyoqXG4gICAqIG1heWJlUHJvY2VzcyBpcyBjYWxsZWQgZHVyaW5nIHRoZSByZWN1cnNpdmUgdHJhdmVyc2FsIG9mIHRoZSBwcm9ncmFtJ3MgQVNULlxuICAgKlxuICAgKiBAcmV0dXJuIFRydWUgaWYgdGhlIG5vZGUgd2FzIHByb2Nlc3NlZC9lbWl0dGVkLCBmYWxzZSBpZiBpdCBzaG91bGQgYmUgZW1pdHRlZCBhcyBpcy5cbiAgICovXG4gIHByb3RlY3RlZCBtYXliZVByb2Nlc3Mobm9kZTogdHMuTm9kZSk6IGJvb2xlYW4ge1xuICAgIHN3aXRjaCAobm9kZS5raW5kKSB7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uOlxuICAgICAgICBjb25zdCBwcm9wQWNjZXNzID0gbm9kZSBhcyB0cy5Qcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb247XG4gICAgICAgIC8vIFdlJ3JlIGxvb2tpbmcgZm9yIGFuIGV4cHJlc3Npb24gb2YgdGhlIGZvcm06XG4gICAgICAgIC8vICAgbW9kdWxlX25hbWVfdmFyLmRlZmF1bHRcbiAgICAgICAgaWYgKGdldElkZW50aWZpZXJUZXh0KHByb3BBY2Nlc3MubmFtZSkgIT09ICdkZWZhdWx0JykgYnJlYWs7XG4gICAgICAgIGlmIChwcm9wQWNjZXNzLmV4cHJlc3Npb24ua2luZCAhPT0gdHMuU3ludGF4S2luZC5JZGVudGlmaWVyKSBicmVhaztcbiAgICAgICAgY29uc3QgbGhzID0gZ2V0SWRlbnRpZmllclRleHQocHJvcEFjY2Vzcy5leHByZXNzaW9uIGFzIHRzLklkZW50aWZpZXIpO1xuICAgICAgICBpZiAoIXRoaXMubmFtZXNwYWNlSW1wb3J0cy5oYXMobGhzKSkgYnJlYWs7XG4gICAgICAgIC8vIEVtaXQgdGhlIHNhbWUgZXhwcmVzc2lvbiwgd2l0aCBzcGFjZXMgdG8gcmVwbGFjZSB0aGUgXCIuZGVmYXVsdFwiIHBhcnRcbiAgICAgICAgLy8gc28gdGhhdCBzb3VyY2UgbWFwcyBzdGlsbCBsaW5lIHVwLlxuICAgICAgICB0aGlzLndyaXRlTGVhZGluZ1RyaXZpYShub2RlKTtcbiAgICAgICAgdGhpcy5lbWl0KGAke2xoc30gICAgICAgIGApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogR2VuZXJhdGVzIGEgbmV3IHZhcmlhYmxlIG5hbWUgaW5zaWRlIHRoZSB0c2lja2xlXyBuYW1lc3BhY2UuICovXG4gIGdlbmVyYXRlRnJlc2hWYXJpYWJsZU5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYHRzaWNrbGVfbW9kdWxlXyR7dGhpcy51bnVzZWRJbmRleCsrfV9gO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgVHlwZVNjcmlwdCdzIEpTK0NvbW1vbkpTIG91dHB1dCB0byBDbG9zdXJlIGdvb2cubW9kdWxlIGV0Yy5cbiAqIEZvciB1c2UgYXMgYSBwb3N0cHJvY2Vzc2luZyBzdGVwICphZnRlciogVHlwZVNjcmlwdCBlbWl0cyBKYXZhU2NyaXB0LlxuICpcbiAqIEBwYXJhbSBmaWxlTmFtZSBUaGUgc291cmNlIGZpbGUgbmFtZS5cbiAqIEBwYXJhbSBtb2R1bGVJZCBUaGUgXCJtb2R1bGUgaWRcIiwgYSBtb2R1bGUtaWRlbnRpZnlpbmcgc3RyaW5nIHRoYXQgaXNcbiAqICAgICB0aGUgdmFsdWUgbW9kdWxlLmlkIGluIHRoZSBzY29wZSBvZiB0aGUgbW9kdWxlLlxuICogQHBhcmFtIHBhdGhUb01vZHVsZU5hbWUgQSBmdW5jdGlvbiB0aGF0IG1hcHMgYSBmaWxlc3lzdGVtIC50cyBwYXRoIHRvIGFcbiAqICAgICBDbG9zdXJlIG1vZHVsZSBuYW1lLCBhcyBmb3VuZCBpbiBhIGdvb2cucmVxdWlyZSgnLi4uJykgc3RhdGVtZW50LlxuICogICAgIFRoZSBjb250ZXh0IHBhcmFtZXRlciBpcyB0aGUgcmVmZXJlbmNpbmcgZmlsZSwgdXNlZCBmb3IgcmVzb2x2aW5nXG4gKiAgICAgaW1wb3J0cyB3aXRoIHJlbGF0aXZlIHBhdGhzIGxpa2UgXCJpbXBvcnQgKiBhcyBmb28gZnJvbSAnLi4vZm9vJztcIi5cbiAqIEBwYXJhbSBwcmVsdWRlIEFuIGFkZGl0aW9uYWwgcHJlbHVkZSB0byBpbnNlcnQgYWZ0ZXIgdGhlIGBnb29nLm1vZHVsZWAgY2FsbCxcbiAqICAgICBlLmcuIHdpdGggYWRkaXRpb25hbCBpbXBvcnRzIG9yIHJlcXVpcmVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0VTNShob3N0OiBFczVQcm9jZXNzb3JIb3N0LCBmaWxlTmFtZTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOlxuICAgIHtvdXRwdXQ6IHN0cmluZywgcmVmZXJlbmNlZE1vZHVsZXM6IHN0cmluZ1tdfSB7XG4gIGNvbnN0IGZpbGUgPSB0cy5jcmVhdGVTb3VyY2VGaWxlKGZpbGVOYW1lLCBjb250ZW50LCB0cy5TY3JpcHRUYXJnZXQuRVM1LCB0cnVlKTtcbiAgcmV0dXJuIG5ldyBFUzVQcm9jZXNzb3IoaG9zdCwgZmlsZSkucHJvY2VzcygpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydENvbW1vbkpzVG9Hb29nTW9kdWxlSWZOZWVkZWQoXG4gICAgaG9zdDogRXM1UHJvY2Vzc29ySG9zdCwgbW9kdWxlc01hbmlmZXN0OiBNb2R1bGVzTWFuaWZlc3QsIGZpbGVOYW1lOiBzdHJpbmcsXG4gICAgY29udGVudDogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKCFob3N0Lmdvb2dtb2R1bGUgfHwgaXNEdHNGaWxlTmFtZShmaWxlTmFtZSkpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBjb25zdCB7b3V0cHV0LCByZWZlcmVuY2VkTW9kdWxlc30gPSBwcm9jZXNzRVM1KGhvc3QsIGZpbGVOYW1lLCBjb250ZW50KTtcblxuICBjb25zdCBtb2R1bGVOYW1lID0gaG9zdC5wYXRoVG9Nb2R1bGVOYW1lKCcnLCBmaWxlTmFtZSk7XG4gIG1vZHVsZXNNYW5pZmVzdC5hZGRNb2R1bGUoZmlsZU5hbWUsIG1vZHVsZU5hbWUpO1xuICBmb3IgKGNvbnN0IHJlZmVyZW5jZWQgb2YgcmVmZXJlbmNlZE1vZHVsZXMpIHtcbiAgICBtb2R1bGVzTWFuaWZlc3QuYWRkUmVmZXJlbmNlZE1vZHVsZShmaWxlTmFtZSwgcmVmZXJlbmNlZCk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuIl19