/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/transformer_util", ["require", "exports", "tsickle/src/typescript", "tsickle/src/util"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ts = require("tsickle/src/typescript");
    var util_1 = require("tsickle/src/util");
    /**
     * Adjusts the given CustomTransformers with additional transformers
     * to fix bugs in TypeScript.
     */
    function createCustomTransformers(given) {
        var before = given.before || [];
        before.unshift(addFileContexts);
        before.push(prepareNodesBeforeTypeScriptTransform);
        var after = given.after || [];
        after.unshift(emitMissingSyntheticCommentsAfterTypescriptTransform);
        return { before: before, after: after };
    }
    exports.createCustomTransformers = createCustomTransformers;
    /**
     * Transform that adds the FileContext to the TransformationContext.
     */
    function addFileContexts(context) {
        return function (sourceFile) {
            context.fileContext = new FileContext(sourceFile);
            return sourceFile;
        };
    }
    function assertFileContext(context, sourceFile) {
        if (!context.fileContext) {
            throw new Error("Illegal State: FileContext not initialized. " +
                "Did you forget to add the \"firstTransform\" as first transformer? " +
                ("File: " + sourceFile.fileName));
        }
        if (context.fileContext.file.fileName !== sourceFile.fileName) {
            throw new Error("Illegal State: File of the FileContext does not match. File: " + sourceFile.fileName);
        }
        return context.fileContext;
    }
    /**
     * A context that stores information per file to e.g. allow communication
     * between transformers.
     * There is one ts.TransformationContext per emit,
     * but files are handled sequentially by all transformers. Thefore we can
     * store file related information on a property on the ts.TransformationContext,
     * given that we reset it in the first transformer.
     */
    var FileContext = /** @class */ (function () {
        function FileContext(file) {
            this.file = file;
            /**
             * Stores the parent node for all processed nodes.
             * This is needed for nodes from the parse tree that are used
             * in a synthetic node as must not modify these, even though they
             * have a new parent now.
             */
            this.syntheticNodeParents = new Map();
            this.importOrReexportDeclarations = [];
            this.lastCommentEnd = -1;
        }
        return FileContext;
    }());
    /**
     * Transform that needs to be executed right before TypeScript's transform.
     *
     * This prepares the node tree to workaround some bugs in the TypeScript emitter.
     */
    function prepareNodesBeforeTypeScriptTransform(context) {
        return function (sourceFile) {
            var fileCtx = assertFileContext(context, sourceFile);
            var nodePath = [];
            visitNode(sourceFile);
            return sourceFile;
            function visitNode(node) {
                var startNode = node;
                var parent = nodePath[nodePath.length - 1];
                if (node.flags & ts.NodeFlags.Synthesized) {
                    // Set `parent` for synthetic nodes as well,
                    // as otherwise the TS emit will crash for decorators.
                    // Note: don't update the `parent` of original nodes, as:
                    // 1) we don't want to change them at all
                    // 2) TS emit becomes errorneous in some cases if we add a synthetic parent.
                    // see https://github.com/Microsoft/TypeScript/issues/17384
                    node.parent = parent;
                }
                fileCtx.syntheticNodeParents.set(node, parent);
                var originalNode = ts.getOriginalNode(node);
                // Needed so that e.g. `module { ... }` prints the variable statement
                // before the closure.
                // See https://github.com/Microsoft/TypeScript/issues/17596
                // tslint:disable-next-line:no-any as `symbol` is @internal in typescript.
                node.symbol = originalNode.symbol;
                if (originalNode && node.kind === ts.SyntaxKind.ExportDeclaration) {
                    var originalEd = originalNode;
                    var ed = node;
                    if (!!originalEd.exportClause !== !!ed.exportClause) {
                        // Tsickle changes `export * ...` into named exports.
                        // In this case, don't set the original node for the ExportDeclaration
                        // as otherwise TypeScript does not emit the exports.
                        // See https://github.com/Microsoft/TypeScript/issues/17597
                        ts.setOriginalNode(node, undefined);
                    }
                }
                if (node.kind === ts.SyntaxKind.ImportDeclaration ||
                    node.kind === ts.SyntaxKind.ExportDeclaration) {
                    var ied = node;
                    if (ied.moduleSpecifier) {
                        fileCtx.importOrReexportDeclarations.push(ied);
                    }
                }
                // recurse
                nodePath.push(node);
                node.forEachChild(visitNode);
                nodePath.pop();
            }
        };
    }
    /**
     * Transform that needs to be executed after TypeScript's transform.
     *
     * This fixes places where the TypeScript transformer does not
     * emit synthetic comments.
     *
     * See https://github.com/Microsoft/TypeScript/issues/17594
     */
    function emitMissingSyntheticCommentsAfterTypescriptTransform(context) {
        return function (sourceFile) {
            var fileContext = assertFileContext(context, sourceFile);
            var nodePath = [];
            visitNode(sourceFile);
            context.fileContext = undefined;
            return sourceFile;
            function visitNode(node) {
                if (node.kind === ts.SyntaxKind.Identifier) {
                    var parent1 = fileContext.syntheticNodeParents.get(node);
                    var parent2 = parent1 && fileContext.syntheticNodeParents.get(parent1);
                    var parent3 = parent2 && fileContext.syntheticNodeParents.get(parent2);
                    if (parent1 && parent1.kind === ts.SyntaxKind.PropertyDeclaration) {
                        // TypeScript ignores synthetic comments on (static) property declarations
                        // with initializers.
                        // find the parent ExpressionStatement like MyClass.foo = ...
                        var expressionStmt = lastNodeWith(nodePath, function (node) { return node.kind === ts.SyntaxKind.ExpressionStatement; });
                        if (expressionStmt) {
                            ts.setSyntheticLeadingComments(expressionStmt, ts.getSyntheticLeadingComments(parent1) || []);
                        }
                    }
                    else if (parent3 && parent3.kind === ts.SyntaxKind.VariableStatement &&
                        util_1.hasModifierFlag(parent3, ts.ModifierFlags.Export)) {
                        // TypeScript ignores synthetic comments on exported variables.
                        // find the parent ExpressionStatement like exports.foo = ...
                        var expressionStmt = lastNodeWith(nodePath, function (node) { return node.kind === ts.SyntaxKind.ExpressionStatement; });
                        if (expressionStmt) {
                            ts.setSyntheticLeadingComments(expressionStmt, ts.getSyntheticLeadingComments(parent3) || []);
                        }
                    }
                }
                // TypeScript ignores synthetic comments on reexport / import statements.
                // The code below re-adds them one the converted CommonJS import statements, and resets the
                // text range to prevent previous comments from being emitted.
                if (isCommonJsRequireStatement(node) && fileContext.importOrReexportDeclarations) {
                    // Locate the original import/export declaration via the
                    // text range.
                    var importOrReexportDeclaration = fileContext.importOrReexportDeclarations.find(function (ied) { return ied.pos === node.pos; });
                    if (importOrReexportDeclaration) {
                        ts.setSyntheticLeadingComments(node, ts.getSyntheticLeadingComments(importOrReexportDeclaration) || []);
                    }
                    // Need to clear the textRange for ImportDeclaration / ExportDeclaration as
                    // otherwise TypeScript would emit the original comments even if we set the
                    // ts.EmitFlag.NoComments. (see also resetNodeTextRangeToPreventDuplicateComments below)
                    ts.setSourceMapRange(node, { pos: node.pos, end: node.end });
                    ts.setTextRange(node, { pos: -1, end: -1 });
                }
                nodePath.push(node);
                node.forEachChild(visitNode);
                nodePath.pop();
            }
        };
    }
    function isCommonJsRequireStatement(node) {
        // CommonJS requires can be either "var x = require('...');" or (for side effect imports), just
        // "require('...');".
        var callExpr;
        if (ts.isVariableStatement(node)) {
            var varStmt = node;
            var decls = varStmt.declarationList.declarations;
            var init = void 0;
            if (decls.length !== 1 || !(init = decls[0].initializer) ||
                init.kind !== ts.SyntaxKind.CallExpression) {
                return false;
            }
            callExpr = init;
        }
        else if (ts.isExpressionStatement(node) && ts.isCallExpression(node.expression)) {
            callExpr = node.expression;
        }
        else {
            return false;
        }
        if (callExpr.expression.kind !== ts.SyntaxKind.Identifier ||
            callExpr.expression.text !== 'require' ||
            callExpr.arguments.length !== 1) {
            return false;
        }
        var moduleExpr = callExpr.arguments[0];
        return moduleExpr.kind === ts.SyntaxKind.StringLiteral;
    }
    function lastNodeWith(nodes, predicate) {
        for (var i = nodes.length - 1; i >= 0; i--) {
            var node = nodes[i];
            if (predicate(node)) {
                return node;
            }
        }
        return null;
    }
    /**
     * Convert comment text ranges before and after a node
     * into ts.SynthesizedComments for the node and prevent the
     * comment text ranges to be emitted, to allow
     * changing these comments.
     *
     * This function takes a visitor to be able to do some
     * state management after the caller is done changing a node.
     */
    function visitNodeWithSynthesizedComments(context, sourceFile, node, visitor) {
        if (node.flags & ts.NodeFlags.Synthesized) {
            return visitor(node);
        }
        if (node.kind === ts.SyntaxKind.Block) {
            var block_1 = node;
            node = visitNodeStatementsWithSynthesizedComments(context, sourceFile, node, block_1.statements, function (node, stmts) { return visitor(ts.updateBlock(block_1, stmts)); });
        }
        else if (node.kind === ts.SyntaxKind.SourceFile) {
            node = visitNodeStatementsWithSynthesizedComments(context, sourceFile, node, sourceFile.statements, function (node, stmts) { return visitor(updateSourceFileNode(sourceFile, stmts)); });
        }
        else {
            var fileContext = assertFileContext(context, sourceFile);
            var leadingLastCommentEnd = synthesizeLeadingComments(sourceFile, node, fileContext.lastCommentEnd);
            var trailingLastCommentEnd = synthesizeTrailingComments(sourceFile, node);
            if (leadingLastCommentEnd !== -1) {
                fileContext.lastCommentEnd = leadingLastCommentEnd;
            }
            node = visitor(node);
            if (trailingLastCommentEnd !== -1) {
                fileContext.lastCommentEnd = trailingLastCommentEnd;
            }
        }
        return resetNodeTextRangeToPreventDuplicateComments(node);
    }
    exports.visitNodeWithSynthesizedComments = visitNodeWithSynthesizedComments;
    /**
     * Reset the text range for some special nodes as otherwise TypeScript
     * would always emit the original comments for them.
     * See https://github.com/Microsoft/TypeScript/issues/17594
     *
     * @param node
     */
    function resetNodeTextRangeToPreventDuplicateComments(node) {
        ts.setEmitFlags(node, (ts.getEmitFlags(node) || 0) | ts.EmitFlags.NoComments);
        // See also emitMissingSyntheticCommentsAfterTypescriptTransform.
        // Note: Don't reset the textRange for ts.ExportDeclaration / ts.ImportDeclaration
        // until after the TypeScript transformer as we need the source location
        // to map the generated `require` calls back to the original
        // ts.ExportDeclaration / ts.ImportDeclaration nodes.
        var allowTextRange = node.kind !== ts.SyntaxKind.ClassDeclaration &&
            node.kind !== ts.SyntaxKind.VariableDeclaration &&
            !(node.kind === ts.SyntaxKind.VariableStatement &&
                util_1.hasModifierFlag(node, ts.ModifierFlags.Export));
        if (node.kind === ts.SyntaxKind.PropertyDeclaration) {
            allowTextRange = false;
            var pd = node;
            node = ts.updateProperty(pd, pd.decorators, pd.modifiers, resetTextRange(pd.name), pd.questionToken, pd.type, pd.initializer);
        }
        if (!allowTextRange) {
            node = resetTextRange(node);
        }
        return node;
        function resetTextRange(node) {
            if (!(node.flags & ts.NodeFlags.Synthesized)) {
                // need to clone as we don't want to modify source nodes,
                // as the parsed SourceFiles could be cached!
                node = ts.getMutableClone(node);
            }
            var textRange = { pos: node.pos, end: node.end };
            ts.setSourceMapRange(node, textRange);
            ts.setTextRange(node, { pos: -1, end: -1 });
            return node;
        }
    }
    /**
     * Reads in the leading comment text ranges of the given node,
     * converts them into `ts.SyntheticComment`s and stores them on the node.
     *
     * Note: This would be greatly simplified with https://github.com/Microsoft/TypeScript/issues/17615.
     *
     * @param lastCommentEnd The end of the last comment
     * @return The end of the last found comment, -1 if no comment was found.
     */
    function synthesizeLeadingComments(sourceFile, node, lastCommentEnd) {
        var parent = node.parent;
        var sharesStartWithParent = parent && parent.kind !== ts.SyntaxKind.Block &&
            parent.kind !== ts.SyntaxKind.SourceFile && parent.getFullStart() === node.getFullStart();
        if (sharesStartWithParent || lastCommentEnd >= node.getStart()) {
            return -1;
        }
        var adjustedNodeFullStart = Math.max(lastCommentEnd, node.getFullStart());
        var leadingComments = getAllLeadingCommentRanges(sourceFile, adjustedNodeFullStart, node.getStart());
        if (leadingComments && leadingComments.length) {
            ts.setSyntheticLeadingComments(node, synthesizeCommentRanges(sourceFile, leadingComments));
            return node.getStart();
        }
        return -1;
    }
    /**
     * Reads in the trailing comment text ranges of the given node,
     * converts them into `ts.SyntheticComment`s and stores them on the node.
     *
     * Note: This would be greatly simplified with https://github.com/Microsoft/TypeScript/issues/17615.
     *
     * @return The end of the last found comment, -1 if no comment was found.
     */
    function synthesizeTrailingComments(sourceFile, node) {
        var parent = node.parent;
        var sharesEndWithParent = parent && parent.kind !== ts.SyntaxKind.Block &&
            parent.kind !== ts.SyntaxKind.SourceFile && parent.getEnd() === node.getEnd();
        if (sharesEndWithParent) {
            return -1;
        }
        var trailingComments = ts.getTrailingCommentRanges(sourceFile.text, node.getEnd());
        if (trailingComments && trailingComments.length) {
            ts.setSyntheticTrailingComments(node, synthesizeCommentRanges(sourceFile, trailingComments));
            return trailingComments[trailingComments.length - 1].end;
        }
        return -1;
    }
    function arrayOf(value) {
        return value ? [value] : [];
    }
    /**
     * Convert leading/trailing detached comment ranges of statement arrays
     * (e.g. the statements of a ts.SourceFile or ts.Block) into
     * `ts.NonEmittedStatement`s with `ts.SynthesizedComment`s and
     * prepends / appends them to the given statement array.
     * This is needed to allow changing these comments.
     *
     * This function takes a visitor to be able to do some
     * state management after the caller is done changing a node.
     */
    function visitNodeStatementsWithSynthesizedComments(context, sourceFile, node, statements, visitor) {
        var leading = synthesizeDetachedLeadingComments(sourceFile, node, statements);
        var trailing = synthesizeDetachedTrailingComments(sourceFile, node, statements);
        if (leading.commentStmt || trailing.commentStmt) {
            var newStatements = __spread(arrayOf(leading.commentStmt), statements, arrayOf(trailing.commentStmt));
            statements = ts.setTextRange(ts.createNodeArray(newStatements), { pos: -1, end: -1 });
            /**
             * The visitor creates a new node with the new statements. However, doing so
             * reveals a TypeScript bug.
             * To reproduce comment out the line below and compile:
             *
             * // ......
             *
             * abstract class A {
             * }
             * abstract class B extends A {
             *   // ......
             * }
             *
             * Note that newlines are significant. This would result in the following:
             * runtime error "TypeError: Cannot read property 'members' of undefined".
             *
             * The line below is a workaround that ensures that updateSourceFileNode and
             * updateBlock never create new Nodes.
             * TODO(#634): file a bug with TS team.
             */
            node.statements = statements;
            var fileContext = assertFileContext(context, sourceFile);
            if (leading.lastCommentEnd !== -1) {
                fileContext.lastCommentEnd = leading.lastCommentEnd;
            }
            node = visitor(node, statements);
            if (trailing.lastCommentEnd !== -1) {
                fileContext.lastCommentEnd = trailing.lastCommentEnd;
            }
            return node;
        }
        return visitor(node, statements);
    }
    /**
     * Convert leading detached comment ranges of statement arrays
     * (e.g. the statements of a ts.SourceFile or ts.Block) into a
     * `ts.NonEmittedStatement` with `ts.SynthesizedComment`s.
     *
     * A Detached leading comment is the first comment in a SourceFile / Block
     * that is separated with a newline from the first statement.
     *
     * Note: This would be greatly simplified with https://github.com/Microsoft/TypeScript/issues/17615.
     */
    function synthesizeDetachedLeadingComments(sourceFile, node, statements) {
        var triviaEnd = statements.end;
        if (statements.length) {
            triviaEnd = statements[0].getStart();
        }
        var detachedComments = getDetachedLeadingCommentRanges(sourceFile, statements.pos, triviaEnd);
        if (!detachedComments.length) {
            return { commentStmt: null, lastCommentEnd: -1 };
        }
        var lastCommentEnd = detachedComments[detachedComments.length - 1].end;
        var commentStmt = createNotEmittedStatement(sourceFile);
        ts.setSyntheticTrailingComments(commentStmt, synthesizeCommentRanges(sourceFile, detachedComments));
        return { commentStmt: commentStmt, lastCommentEnd: lastCommentEnd };
    }
    /**
     * Convert trailing detached comment ranges of statement arrays
     * (e.g. the statements of a ts.SourceFile or ts.Block) into a
     * `ts.NonEmittedStatement` with `ts.SynthesizedComment`s.
     *
     * A Detached trailing comment are all comments after the first newline
     * the follows the last statement in a SourceFile / Block.
     *
     * Note: This would be greatly simplified with https://github.com/Microsoft/TypeScript/issues/17615.
     */
    function synthesizeDetachedTrailingComments(sourceFile, node, statements) {
        var trailingCommentStart = statements.end;
        if (statements.length) {
            var lastStmt = statements[statements.length - 1];
            var lastStmtTrailingComments = ts.getTrailingCommentRanges(sourceFile.text, lastStmt.end);
            if (lastStmtTrailingComments && lastStmtTrailingComments.length) {
                trailingCommentStart = lastStmtTrailingComments[lastStmtTrailingComments.length - 1].end;
            }
        }
        var detachedComments = getAllLeadingCommentRanges(sourceFile, trailingCommentStart, node.end);
        if (!detachedComments || !detachedComments.length) {
            return { commentStmt: null, lastCommentEnd: -1 };
        }
        var lastCommentEnd = detachedComments[detachedComments.length - 1].end;
        var commentStmt = createNotEmittedStatement(sourceFile);
        ts.setSyntheticLeadingComments(commentStmt, synthesizeCommentRanges(sourceFile, detachedComments));
        return { commentStmt: commentStmt, lastCommentEnd: lastCommentEnd };
    }
    /**
     * Calculates the the detached leading comment ranges in an area of a SourceFile.
     * @param sourceFile The source file
     * @param start Where to start scanning
     * @param end Where to end scanning
     */
    // Note: This code is based on compiler/comments.ts in TypeScript
    function getDetachedLeadingCommentRanges(sourceFile, start, end) {
        var leadingComments = getAllLeadingCommentRanges(sourceFile, start, end);
        if (!leadingComments || !leadingComments.length) {
            return [];
        }
        var detachedComments = [];
        var lastComment = undefined;
        try {
            for (var leadingComments_1 = __values(leadingComments), leadingComments_1_1 = leadingComments_1.next(); !leadingComments_1_1.done; leadingComments_1_1 = leadingComments_1.next()) {
                var comment = leadingComments_1_1.value;
                if (lastComment) {
                    var lastCommentLine = getLineOfPos(sourceFile, lastComment.end);
                    var commentLine = getLineOfPos(sourceFile, comment.pos);
                    if (commentLine >= lastCommentLine + 2) {
                        // There was a blank line between the last comment and this comment.  This
                        // comment is not part of the copyright comments.  Return what we have so
                        // far.
                        break;
                    }
                }
                detachedComments.push(comment);
                lastComment = comment;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (leadingComments_1_1 && !leadingComments_1_1.done && (_a = leadingComments_1.return)) _a.call(leadingComments_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (detachedComments.length) {
            // All comments look like they could have been part of the copyright header.  Make
            // sure there is at least one blank line between it and the node.  If not, it's not
            // a copyright header.
            var lastCommentLine = getLineOfPos(sourceFile, detachedComments[detachedComments.length - 1].end);
            var nodeLine = getLineOfPos(sourceFile, end);
            if (nodeLine >= lastCommentLine + 2) {
                // Valid detachedComments
                return detachedComments;
            }
        }
        return [];
        var e_1, _a;
    }
    function getLineOfPos(sourceFile, pos) {
        return ts.getLineAndCharacterOfPosition(sourceFile, pos).line;
    }
    /**
     * Converts `ts.CommentRange`s into `ts.SynthesizedComment`s
     * @param sourceFile
     * @param parsedComments
     */
    function synthesizeCommentRanges(sourceFile, parsedComments) {
        var synthesizedComments = [];
        parsedComments.forEach(function (_a, commentIdx) {
            var kind = _a.kind, pos = _a.pos, end = _a.end, hasTrailingNewLine = _a.hasTrailingNewLine;
            var commentText = sourceFile.text.substring(pos, end).trim();
            if (kind === ts.SyntaxKind.MultiLineCommentTrivia) {
                commentText = commentText.replace(/(^\/\*)|(\*\/$)/g, '');
            }
            else if (kind === ts.SyntaxKind.SingleLineCommentTrivia) {
                if (commentText.startsWith('///')) {
                    // tripple-slash comments are typescript specific, ignore them in the output.
                    return;
                }
                commentText = commentText.replace(/(^\/\/)/g, '');
            }
            synthesizedComments.push({ kind: kind, text: commentText, hasTrailingNewLine: hasTrailingNewLine, pos: -1, end: -1 });
        });
        return synthesizedComments;
    }
    /**
     * Creates a non emitted statement that can be used to store synthesized comments.
     */
    function createNotEmittedStatement(sourceFile) {
        var stmt = ts.createNotEmittedStatement(sourceFile);
        ts.setOriginalNode(stmt, undefined);
        ts.setTextRange(stmt, { pos: 0, end: 0 });
        ts.setEmitFlags(stmt, ts.EmitFlags.CustomPrologue);
        return stmt;
    }
    exports.createNotEmittedStatement = createNotEmittedStatement;
    /**
     * Returns the leading comment ranges in the source file that start at the given position.
     * This is the same as `ts.getLeadingCommentRanges`, except that it does not skip
     * comments before the first newline in the range.
     *
     * @param sourceFile
     * @param start Where to start scanning
     * @param end Where to end scanning
     */
    function getAllLeadingCommentRanges(sourceFile, start, end) {
        // exeute ts.getLeadingCommentRanges with pos = 0 so that it does not skip
        // comments until the first newline.
        var commentRanges = ts.getLeadingCommentRanges(sourceFile.text.substring(start, end), 0) || [];
        return commentRanges.map(function (cr) { return ({
            hasTrailingNewLine: cr.hasTrailingNewLine,
            kind: cr.kind,
            pos: cr.pos + start,
            end: cr.end + start
        }); });
    }
    /**
     * This is a version of `ts.visitEachChild` that works that calls our version
     * of `updateSourceFileNode`, so that typescript doesn't lose type information
     * for property decorators.
     * See https://github.com/Microsoft/TypeScript/issues/17384
     *
     * @param sf
     * @param statements
     */
    function visitEachChild(node, visitor, context) {
        if (node.kind === ts.SyntaxKind.SourceFile) {
            var sf = node;
            return updateSourceFileNode(sf, ts.visitLexicalEnvironment(sf.statements, visitor, context));
        }
        return ts.visitEachChild(node, visitor, context);
    }
    exports.visitEachChild = visitEachChild;
    /**
     * This is a version of `ts.updateSourceFileNode` that works
     * well with property decorators.
     * See https://github.com/Microsoft/TypeScript/issues/17384
     * TODO(#634): This has been fixed in TS 2.5. Investigate removal.
     *
     * @param sf
     * @param statements
     */
    function updateSourceFileNode(sf, statements) {
        if (statements === sf.statements) {
            return sf;
        }
        // Note: Need to clone the original file (and not use `ts.updateSourceFileNode`)
        // as otherwise TS fails when resolving types for decorators.
        sf = ts.getMutableClone(sf);
        sf.statements = statements;
        return sf;
    }
    exports.updateSourceFileNode = updateSourceFileNode;
    // Copied from TypeScript
    function isTypeNodeKind(kind) {
        return (kind >= ts.SyntaxKind.FirstTypeNode && kind <= ts.SyntaxKind.LastTypeNode) ||
            kind === ts.SyntaxKind.AnyKeyword || kind === ts.SyntaxKind.NumberKeyword ||
            kind === ts.SyntaxKind.ObjectKeyword || kind === ts.SyntaxKind.BooleanKeyword ||
            kind === ts.SyntaxKind.StringKeyword || kind === ts.SyntaxKind.SymbolKeyword ||
            kind === ts.SyntaxKind.ThisKeyword || kind === ts.SyntaxKind.VoidKeyword ||
            kind === ts.SyntaxKind.UndefinedKeyword || kind === ts.SyntaxKind.NullKeyword ||
            kind === ts.SyntaxKind.NeverKeyword || kind === ts.SyntaxKind.ExpressionWithTypeArguments;
    }
    exports.isTypeNodeKind = isTypeNodeKind;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNmb3JtZXJfdXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy90cmFuc2Zvcm1lcl91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBRUgsMkNBQW1DO0lBQ25DLHlDQUF1QztJQUV2Qzs7O09BR0c7SUFDSCxrQ0FBeUMsS0FBNEI7UUFDbkUsSUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUM7UUFDbEMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUNoQyxNQUFNLENBQUMsSUFBSSxDQUFDLHFDQUFxQyxDQUFDLENBQUM7UUFDbkQsSUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssSUFBSSxFQUFFLENBQUM7UUFDaEMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxvREFBb0QsQ0FBQyxDQUFDO1FBQ3BFLE9BQU8sRUFBQyxNQUFNLFFBQUEsRUFBRSxLQUFLLE9BQUEsRUFBQyxDQUFDO0lBQ3pCLENBQUM7SUFQRCw0REFPQztJQUVEOztPQUVHO0lBQ0gseUJBQXlCLE9BQWlDO1FBQ3hELE9BQU8sVUFBQyxVQUF5QjtZQUM5QixPQUFpQyxDQUFDLFdBQVcsR0FBRyxJQUFJLFdBQVcsQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUM3RSxPQUFPLFVBQVUsQ0FBQztRQUNwQixDQUFDLENBQUM7SUFDSixDQUFDO0lBRUQsMkJBQTJCLE9BQThCLEVBQUUsVUFBeUI7UUFDbEYsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUU7WUFDeEIsTUFBTSxJQUFJLEtBQUssQ0FDWCw4Q0FBOEM7Z0JBQzlDLHFFQUFtRTtpQkFDbkUsV0FBUyxVQUFVLENBQUMsUUFBVSxDQUFBLENBQUMsQ0FBQztTQUNyQztRQUNELElBQUksT0FBTyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMs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QUFFLENBQUMsVUFBVSxDQUFDLGFBQWEsSUFBSSxJQUFJLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQyxhQUFhO1lBQzVFLElBQUksS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsSUFBSSxJQUFJLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXO1lBQ3hFLElBQUksS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLGdCQUFnQixJQUFJLElBQUksS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVc7WUFDN0UsSUFBSSxLQUFLLEVBQUUsQ0FBQyxVQUFVLENBQUMsWUFBWSxJQUFJLElBQUksS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLDJCQUEyQixDQUFDO0lBQ2hHLENBQUM7SUFSRCx3Q0FRQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0ICogYXMgdHMgZnJvbSAnLi90eXBlc2NyaXB0JztcbmltcG9ydCB7aGFzTW9kaWZpZXJGbGFnfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIEFkanVzdHMgdGhlIGdpdmVuIEN1c3RvbVRyYW5zZm9ybWVycyB3aXRoIGFkZGl0aW9uYWwgdHJhbnNmb3JtZXJzXG4gKiB0byBmaXggYnVncyBpbiBUeXBlU2NyaXB0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ3VzdG9tVHJhbnNmb3JtZXJzKGdpdmVuOiB0cy5DdXN0b21UcmFuc2Zvcm1lcnMpOiB0cy5DdXN0b21UcmFuc2Zvcm1lcnMge1xuICBjb25zdCBiZWZvcmUgPSBnaXZlbi5iZWZvcmUgfHwgW107XG4gIGJlZm9yZS51bnNoaWZ0KGFkZEZpbGVDb250ZXh0cyk7XG4gIGJlZm9yZS5wdXNoKHByZXBhcmVOb2Rlc0JlZm9yZVR5cGVTY3JpcHRUcmFuc2Zvcm0pO1xuICBjb25zdCBhZnRlciA9IGdpdmVuLmFmdGVyIHx8IFtdO1xuICBhZnRlci51bnNoaWZ0KGVtaXRNaXNzaW5nU3ludGhldGljQ29tbWVudHNBZnRlclR5cGVzY3JpcHRUcmFuc2Zvcm0pO1xuICByZXR1cm4ge2JlZm9yZSwgYWZ0ZXJ9O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGF0IGFkZHMgdGhlIEZpbGVDb250ZXh0IHRvIHRoZSBUcmFuc2Zvcm1hdGlvbkNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGFkZEZpbGVDb250ZXh0cyhjb250ZXh0OiB0cy5UcmFuc2Zvcm1hdGlvbkNvbnRleHQpIHtcbiAgcmV0dXJuIChzb3VyY2VGaWxlOiB0cy5Tb3VyY2VGaWxlKSA9PiB7XG4gICAgKGNvbnRleHQgYXMgVHJhbnNmb3JtYXRpb25Db250ZXh0KS5maWxlQ29udGV4dCA9IG5ldyBGaWxlQ29udGV4dChzb3VyY2VGaWxlKTtcbiAgICByZXR1cm4gc291cmNlRmlsZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RmlsZUNvbnRleHQoY29udGV4dDogVHJhbnNmb3JtYXRpb25Db250ZXh0LCBzb3VyY2VGaWxlOiB0cy5Tb3VyY2VGaWxlKTogRmlsZUNvbnRleHQge1xuICBpZiAoIWNvbnRleHQuZmlsZUNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbGxlZ2FsIFN0YXRlOiBGaWxlQ29udGV4dCBub3QgaW5pdGlhbGl6ZWQuIGAgK1xuICAgICAgICBgRGlkIHlvdSBmb3JnZXQgdG8gYWRkIHRoZSBcImZpcnN0VHJhbnNmb3JtXCIgYXMgZmlyc3QgdHJhbnNmb3JtZXI/IGAgK1xuICAgICAgICBgRmlsZTogJHtzb3VyY2VGaWxlLmZpbGVOYW1lfWApO1xuICB9XG4gIGlmIChjb250ZXh0LmZpbGVDb250ZXh0LmZpbGUuZmlsZU5hbWUgIT09IHNvdXJjZUZpbGUuZmlsZU5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbGxlZ2FsIFN0YXRlOiBGaWxlIG9mIHRoZSBGaWxlQ29udGV4dCBkb2VzIG5vdCBtYXRjaC4gRmlsZTogJHtzb3VyY2VGaWxlLmZpbGVOYW1lfWApO1xuICB9XG4gIHJldHVybiBjb250ZXh0LmZpbGVDb250ZXh0O1xufVxuXG4vKipcbiAqIEFuIGV4dGVuZGVkIHZlcnNpb24gb2YgdGhlIFRyYW5zZm9ybWF0aW9uQ29udGV4dCB0aGF0IHN0b3JlcyB0aGUgRmlsZUNvbnRleHQgYXMgd2VsbC5cbiAqL1xuaW50ZXJmYWNlIFRyYW5zZm9ybWF0aW9uQ29udGV4dCBleHRlbmRzIHRzLlRyYW5zZm9ybWF0aW9uQ29udGV4dCB7XG4gIGZpbGVDb250ZXh0PzogRmlsZUNvbnRleHQ7XG59XG5cbi8qKlxuICogQSBjb250ZXh0IHRoYXQgc3RvcmVzIGluZm9ybWF0aW9uIHBlciBmaWxlIHRvIGUuZy4gYWxsb3cgY29tbXVuaWNhdGlvblxuICogYmV0d2VlbiB0cmFuc2Zvcm1lcnMuXG4gKiBUaGVyZSBpcyBvbmUgdHMuVHJhbnNmb3JtYXRpb25Db250ZXh0IHBlciBlbWl0LFxuICogYnV0IGZpbGVzIGFyZSBoYW5kbGVkIHNlcXVlbnRpYWxseSBieSBhbGwgdHJhbnNmb3JtZXJzLiBUaGVmb3JlIHdlIGNhblxuICogc3RvcmUgZmlsZSByZWxhdGVkIGluZm9ybWF0aW9uIG9uIGEgcHJvcGVydHkgb24gdGhlIHRzLlRyYW5zZm9ybWF0aW9uQ29udGV4dCxcbiAqIGdpdmVuIHRoYXQgd2UgcmVzZXQgaXQgaW4gdGhlIGZpcnN0IHRyYW5zZm9ybWVyLlxuICovXG5jbGFzcyBGaWxlQ29udGV4dCB7XG4gIC8qKlxuICAgKiBTdG9yZXMgdGhlIHBhcmVudCBub2RlIGZvciBhbGwgcHJvY2Vzc2VkIG5vZGVzLlxuICAgKiBUaGlzIGlzIG5lZWRlZCBmb3Igbm9kZXMgZnJvbSB0aGUgcGFyc2UgdHJlZSB0aGF0IGFyZSB1c2VkXG4gICAqIGluIGEgc3ludGhldGljIG5vZGUgYXMgbXVzdCBub3QgbW9kaWZ5IHRoZXNlLCBldmVuIHRob3VnaCB0aGV5XG4gICAqIGhhdmUgYSBuZXcgcGFyZW50IG5vdy5cbiAgICovXG4gIHN5bnRoZXRpY05vZGVQYXJlbnRzID0gbmV3IE1hcDx0cy5Ob2RlLCB0cy5Ob2RlfHVuZGVmaW5lZD4oKTtcbiAgaW1wb3J0T3JSZWV4cG9ydERlY2xhcmF0aW9uczogQXJyYXk8dHMuRXhwb3J0RGVjbGFyYXRpb258dHMuSW1wb3J0RGVjbGFyYXRpb24+ID0gW107XG4gIGxhc3RDb21tZW50RW5kID0gLTE7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBmaWxlOiB0cy5Tb3VyY2VGaWxlKSB7fVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGF0IG5lZWRzIHRvIGJlIGV4ZWN1dGVkIHJpZ2h0IGJlZm9yZSBUeXBlU2NyaXB0J3MgdHJhbnNmb3JtLlxuICpcbiAqIFRoaXMgcHJlcGFyZXMgdGhlIG5vZGUgdHJlZSB0byB3b3JrYXJvdW5kIHNvbWUgYnVncyBpbiB0aGUgVHlwZVNjcmlwdCBlbWl0dGVyLlxuICovXG5mdW5jdGlvbiBwcmVwYXJlTm9kZXNCZWZvcmVUeXBlU2NyaXB0VHJhbnNmb3JtKGNvbnRleHQ6IHRzLlRyYW5zZm9ybWF0aW9uQ29udGV4dCkge1xuICByZXR1cm4gKHNvdXJjZUZpbGU6IHRzLlNvdXJjZUZpbGUpID0+IHtcbiAgICBjb25zdCBmaWxlQ3R4ID0gYXNzZXJ0RmlsZUNvbnRleHQoY29udGV4dCwgc291cmNlRmlsZSk7XG5cbiAgICBjb25zdCBub2RlUGF0aDogdHMuTm9kZVtdID0gW107XG4gICAgdmlzaXROb2RlKHNvdXJjZUZpbGUpO1xuICAgIHJldHVybiBzb3VyY2VGaWxlO1xuXG4gICAgZnVuY3Rpb24gdmlzaXROb2RlKG5vZGU6IHRzLk5vZGUpIHtcbiAgICAgIGNvbnN0IHN0YXJ0Tm9kZSA9IG5vZGU7XG4gICAgICBjb25zdCBwYXJlbnQgPSBub2RlUGF0aFtub2RlUGF0aC5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKG5vZGUuZmxhZ3MgJiB0cy5Ob2RlRmxhZ3MuU3ludGhlc2l6ZWQpIHtcbiAgICAgICAgLy8gU2V0IGBwYXJlbnRgIGZvciBzeW50aGV0aWMgbm9kZXMgYXMgd2VsbCxcbiAgICAgICAgLy8gYXMgb3RoZXJ3aXNlIHRoZSBUUyBlbWl0IHdpbGwgY3Jhc2ggZm9yIGRlY29yYXRvcnMuXG4gICAgICAgIC8vIE5vdGU6IGRvbid0IHVwZGF0ZSB0aGUgYHBhcmVudGAgb2Ygb3JpZ2luYWwgbm9kZXMsIGFzOlxuICAgICAgICAvLyAxKSB3ZSBkb24ndCB3YW50IHRvIGNoYW5nZSB0aGVtIGF0IGFsbFxuICAgICAgICAvLyAyKSBUUyBlbWl0IGJlY29tZXMgZXJyb3JuZW91cyBpbiBzb21lIGNhc2VzIGlmIHdlIGFkZCBhIHN5bnRoZXRpYyBwYXJlbnQuXG4gICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzE3Mzg0XG4gICAgICAgIG5vZGUucGFyZW50ID0gcGFyZW50O1xuICAgICAgfVxuICAgICAgZmlsZUN0eC5zeW50aGV0aWNOb2RlUGFyZW50cy5zZXQobm9kZSwgcGFyZW50KTtcblxuICAgICAgY29uc3Qgb3JpZ2luYWxOb2RlID0gdHMuZ2V0T3JpZ2luYWxOb2RlKG5vZGUpO1xuICAgICAgLy8gTmVlZGVkIHNvIHRoYXQgZS5nLiBgbW9kdWxlIHsgLi4uIH1gIHByaW50cyB0aGUgdmFyaWFibGUgc3RhdGVtZW50XG4gICAgICAvLyBiZWZvcmUgdGhlIGNsb3N1cmUuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xNzU5NlxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueSBhcyBgc3ltYm9sYCBpcyBAaW50ZXJuYWwgaW4gdHlwZXNjcmlwdC5cbiAgICAgIChub2RlIGFzIGFueSkuc3ltYm9sID0gKG9yaWdpbmFsTm9kZSBhcyBhbnkpLnN5bWJvbDtcblxuICAgICAgaWYgKG9yaWdpbmFsTm9kZSAmJiBub2RlLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuRXhwb3J0RGVjbGFyYXRpb24pIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxFZCA9IG9yaWdpbmFsTm9kZSBhcyB0cy5FeHBvcnREZWNsYXJhdGlvbjtcbiAgICAgICAgY29uc3QgZWQgPSBub2RlIGFzIHRzLkV4cG9ydERlY2xhcmF0aW9uO1xuICAgICAgICBpZiAoISFvcmlnaW5hbEVkLmV4cG9ydENsYXVzZSAhPT0gISFlZC5leHBvcnRDbGF1c2UpIHtcbiAgICAgICAgICAvLyBUc2lja2xlIGNoYW5nZXMgYGV4cG9ydCAqIC4uLmAgaW50byBuYW1lZCBleHBvcnRzLlxuICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSwgZG9uJ3Qgc2V0IHRoZSBvcmlnaW5hbCBub2RlIGZvciB0aGUgRXhwb3J0RGVjbGFyYXRpb25cbiAgICAgICAgICAvLyBhcyBvdGhlcndpc2UgVHlwZVNjcmlwdCBkb2VzIG5vdCBlbWl0IHRoZSBleHBvcnRzLlxuICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzE3NTk3XG4gICAgICAgICAgdHMuc2V0T3JpZ2luYWxOb2RlKG5vZGUsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUua2luZCA9PT0gdHMuU3ludGF4S2luZC5JbXBvcnREZWNsYXJhdGlvbiB8fFxuICAgICAgICAgIG5vZGUua2luZCA9PT0gdHMuU3ludGF4S2luZC5FeHBvcnREZWNsYXJhdGlvbikge1xuICAgICAgICBjb25zdCBpZWQgPSBub2RlIGFzIHRzLkltcG9ydERlY2xhcmF0aW9uIHwgdHMuRXhwb3J0RGVjbGFyYXRpb247XG4gICAgICAgIGlmIChpZWQubW9kdWxlU3BlY2lmaWVyKSB7XG4gICAgICAgICAgZmlsZUN0eC5pbXBvcnRPclJlZXhwb3J0RGVjbGFyYXRpb25zLnB1c2goaWVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyByZWN1cnNlXG4gICAgICBub2RlUGF0aC5wdXNoKG5vZGUpO1xuICAgICAgbm9kZS5mb3JFYWNoQ2hpbGQodmlzaXROb2RlKTtcbiAgICAgIG5vZGVQYXRoLnBvcCgpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhhdCBuZWVkcyB0byBiZSBleGVjdXRlZCBhZnRlciBUeXBlU2NyaXB0J3MgdHJhbnNmb3JtLlxuICpcbiAqIFRoaXMgZml4ZXMgcGxhY2VzIHdoZXJlIHRoZSBUeXBlU2NyaXB0IHRyYW5zZm9ybWVyIGRvZXMgbm90XG4gKiBlbWl0IHN5bnRoZXRpYyBjb21tZW50cy5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xNzU5NFxuICovXG5mdW5jdGlvbiBlbWl0TWlzc2luZ1N5bnRoZXRpY0NvbW1lbnRzQWZ0ZXJUeXBlc2NyaXB0VHJhbnNmb3JtKGNvbnRleHQ6IHRzLlRyYW5zZm9ybWF0aW9uQ29udGV4dCkge1xuICByZXR1cm4gKHNvdXJjZUZpbGU6IHRzLlNvdXJjZUZpbGUpID0+IHtcbiAgICBjb25zdCBmaWxlQ29udGV4dCA9IGFzc2VydEZpbGVDb250ZXh0KGNvbnRleHQsIHNvdXJjZUZpbGUpO1xuICAgIGNvbnN0IG5vZGVQYXRoOiB0cy5Ob2RlW10gPSBbXTtcbiAgICB2aXNpdE5vZGUoc291cmNlRmlsZSk7XG4gICAgKGNvbnRleHQgYXMgVHJhbnNmb3JtYXRpb25Db250ZXh0KS5maWxlQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc291cmNlRmlsZTtcblxuICAgIGZ1bmN0aW9uIHZpc2l0Tm9kZShub2RlOiB0cy5Ob2RlKSB7XG4gICAgICBpZiAobm9kZS5raW5kID09PSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXIpIHtcbiAgICAgICAgY29uc3QgcGFyZW50MSA9IGZpbGVDb250ZXh0LnN5bnRoZXRpY05vZGVQYXJlbnRzLmdldChub2RlKTtcbiAgICAgICAgY29uc3QgcGFyZW50MiA9IHBhcmVudDEgJiYgZmlsZUNvbnRleHQuc3ludGhldGljTm9kZVBhcmVudHMuZ2V0KHBhcmVudDEpO1xuICAgICAgICBjb25zdCBwYXJlbnQzID0gcGFyZW50MiAmJiBmaWxlQ29udGV4dC5zeW50aGV0aWNOb2RlUGFyZW50cy5nZXQocGFyZW50Mik7XG5cbiAgICAgICAgaWYgKHBhcmVudDEgJiYgcGFyZW50MS5raW5kID09PSB0cy5TeW50YXhLaW5kLlByb3BlcnR5RGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAvLyBUeXBlU2NyaXB0IGlnbm9yZXMgc3ludGhldGljIGNvbW1lbnRzIG9uIChzdGF0aWMpIHByb3BlcnR5IGRlY2xhcmF0aW9uc1xuICAgICAgICAgIC8vIHdpdGggaW5pdGlhbGl6ZXJzLlxuICAgICAgICAgIC8vIGZpbmQgdGhlIHBhcmVudCBFeHByZXNzaW9uU3RhdGVtZW50IGxpa2UgTXlDbGFzcy5mb28gPSAuLi5cbiAgICAgICAgICBjb25zdCBleHByZXNzaW9uU3RtdCA9XG4gICAgICAgICAgICAgIGxhc3ROb2RlV2l0aChub2RlUGF0aCwgKG5vZGUpID0+IG5vZGUua2luZCA9PT0gdHMuU3ludGF4S2luZC5FeHByZXNzaW9uU3RhdGVtZW50KTtcbiAgICAgICAgICBpZiAoZXhwcmVzc2lvblN0bXQpIHtcbiAgICAgICAgICAgIHRzLnNldFN5bnRoZXRpY0xlYWRpbmdDb21tZW50cyhcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uU3RtdCwgdHMuZ2V0U3ludGhldGljTGVhZGluZ0NvbW1lbnRzKHBhcmVudDEpIHx8IFtdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBwYXJlbnQzICYmIHBhcmVudDMua2luZCA9PT0gdHMuU3ludGF4S2luZC5WYXJpYWJsZVN0YXRlbWVudCAmJlxuICAgICAgICAgICAgaGFzTW9kaWZpZXJGbGFnKHBhcmVudDMsIHRzLk1vZGlmaWVyRmxhZ3MuRXhwb3J0KSkge1xuICAgICAgICAgIC8vIFR5cGVTY3JpcHQgaWdub3JlcyBzeW50aGV0aWMgY29tbWVudHMgb24gZXhwb3J0ZWQgdmFyaWFibGVzLlxuICAgICAgICAgIC8vIGZpbmQgdGhlIHBhcmVudCBFeHByZXNzaW9uU3RhdGVtZW50IGxpa2UgZXhwb3J0cy5mb28gPSAuLi5cbiAgICAgICAgICBjb25zdCBleHByZXNzaW9uU3RtdCA9XG4gICAgICAgICAgICAgIGxhc3ROb2RlV2l0aChub2RlUGF0aCwgKG5vZGUpID0+IG5vZGUua2luZCA9PT0gdHMuU3ludGF4S2luZC5FeHByZXNzaW9uU3RhdGVtZW50KTtcbiAgICAgICAgICBpZiAoZXhwcmVzc2lvblN0bXQpIHtcbiAgICAgICAgICAgIHRzLnNldFN5bnRoZXRpY0xlYWRpbmdDb21tZW50cyhcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uU3RtdCwgdHMuZ2V0U3ludGhldGljTGVhZGluZ0NvbW1lbnRzKHBhcmVudDMpIHx8IFtdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFR5cGVTY3JpcHQgaWdub3JlcyBzeW50aGV0aWMgY29tbWVudHMgb24gcmVleHBvcnQgLyBpbXBvcnQgc3RhdGVtZW50cy5cbiAgICAgIC8vIFRoZSBjb2RlIGJlbG93IHJlLWFkZHMgdGhlbSBvbmUgdGhlIGNvbnZlcnRlZCBDb21tb25KUyBpbXBvcnQgc3RhdGVtZW50cywgYW5kIHJlc2V0cyB0aGVcbiAgICAgIC8vIHRleHQgcmFuZ2UgdG8gcHJldmVudCBwcmV2aW91cyBjb21tZW50cyBmcm9tIGJlaW5nIGVtaXR0ZWQuXG4gICAgICBpZiAoaXNDb21tb25Kc1JlcXVpcmVTdGF0ZW1lbnQobm9kZSkgJiYgZmlsZUNvbnRleHQuaW1wb3J0T3JSZWV4cG9ydERlY2xhcmF0aW9ucykge1xuICAgICAgICAvLyBMb2NhdGUgdGhlIG9yaWdpbmFsIGltcG9ydC9leHBvcnQgZGVjbGFyYXRpb24gdmlhIHRoZVxuICAgICAgICAvLyB0ZXh0IHJhbmdlLlxuICAgICAgICBjb25zdCBpbXBvcnRPclJlZXhwb3J0RGVjbGFyYXRpb24gPVxuICAgICAgICAgICAgZmlsZUNvbnRleHQuaW1wb3J0T3JSZWV4cG9ydERlY2xhcmF0aW9ucy5maW5kKGllZCA9PiBpZWQucG9zID09PSBub2RlLnBvcyk7XG4gICAgICAgIGlmIChpbXBvcnRPclJlZXhwb3J0RGVjbGFyYXRpb24pIHtcbiAgICAgICAgICB0cy5zZXRTeW50aGV0aWNMZWFkaW5nQ29tbWVudHMoXG4gICAgICAgICAgICAgIG5vZGUsIHRzLmdldFN5bnRoZXRpY0xlYWRpbmdDb21tZW50cyhpbXBvcnRPclJlZXhwb3J0RGVjbGFyYXRpb24pIHx8IFtdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOZWVkIHRvIGNsZWFyIHRoZSB0ZXh0UmFuZ2UgZm9yIEltcG9ydERlY2xhcmF0aW9uIC8gRXhwb3J0RGVjbGFyYXRpb24gYXNcbiAgICAgICAgLy8gb3RoZXJ3aXNlIFR5cGVTY3JpcHQgd291bGQgZW1pdCB0aGUgb3JpZ2luYWwgY29tbWVudHMgZXZlbiBpZiB3ZSBzZXQgdGhlXG4gICAgICAgIC8vIHRzLkVtaXRGbGFnLk5vQ29tbWVudHMuIChzZWUgYWxzbyByZXNldE5vZGVUZXh0UmFuZ2VUb1ByZXZlbnREdXBsaWNhdGVDb21tZW50cyBiZWxvdylcbiAgICAgICAgdHMuc2V0U291cmNlTWFwUmFuZ2Uobm9kZSwge3Bvczogbm9kZS5wb3MsIGVuZDogbm9kZS5lbmR9KTtcbiAgICAgICAgdHMuc2V0VGV4dFJhbmdlKG5vZGUsIHtwb3M6IC0xLCBlbmQ6IC0xfSk7XG4gICAgICB9XG4gICAgICBub2RlUGF0aC5wdXNoKG5vZGUpO1xuICAgICAgbm9kZS5mb3JFYWNoQ2hpbGQodmlzaXROb2RlKTtcbiAgICAgIG5vZGVQYXRoLnBvcCgpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNDb21tb25Kc1JlcXVpcmVTdGF0ZW1lbnQobm9kZTogdHMuTm9kZSk6IGJvb2xlYW4ge1xuICAvLyBDb21tb25KUyByZXF1aXJlcyBjYW4gYmUgZWl0aGVyIFwidmFyIHggPSByZXF1aXJlKCcuLi4nKTtcIiBvciAoZm9yIHNpZGUgZWZmZWN0IGltcG9ydHMpLCBqdXN0XG4gIC8vIFwicmVxdWlyZSgnLi4uJyk7XCIuXG4gIGxldCBjYWxsRXhwcjogdHMuQ2FsbEV4cHJlc3Npb247XG4gIGlmICh0cy5pc1ZhcmlhYmxlU3RhdGVtZW50KG5vZGUpKSB7XG4gICAgY29uc3QgdmFyU3RtdCA9IG5vZGUgYXMgdHMuVmFyaWFibGVTdGF0ZW1lbnQ7XG4gICAgY29uc3QgZGVjbHMgPSB2YXJTdG10LmRlY2xhcmF0aW9uTGlzdC5kZWNsYXJhdGlvbnM7XG4gICAgbGV0IGluaXQ6IHRzLkV4cHJlc3Npb258dW5kZWZpbmVkO1xuICAgIGlmIChkZWNscy5sZW5ndGggIT09IDEgfHwgIShpbml0ID0gZGVjbHNbMF0uaW5pdGlhbGl6ZXIpIHx8XG4gICAgICAgIGluaXQua2luZCAhPT0gdHMuU3ludGF4S2luZC5DYWxsRXhwcmVzc2lvbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjYWxsRXhwciA9IGluaXQgYXMgdHMuQ2FsbEV4cHJlc3Npb247XG4gIH0gZWxzZSBpZiAodHMuaXNFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUpICYmIHRzLmlzQ2FsbEV4cHJlc3Npb24obm9kZS5leHByZXNzaW9uKSkge1xuICAgIGNhbGxFeHByID0gbm9kZS5leHByZXNzaW9uO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoY2FsbEV4cHIuZXhwcmVzc2lvbi5raW5kICE9PSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXIgfHxcbiAgICAgIChjYWxsRXhwci5leHByZXNzaW9uIGFzIHRzLklkZW50aWZpZXIpLnRleHQgIT09ICdyZXF1aXJlJyB8fFxuICAgICAgY2FsbEV4cHIuYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBtb2R1bGVFeHByID0gY2FsbEV4cHIuYXJndW1lbnRzWzBdO1xuICByZXR1cm4gbW9kdWxlRXhwci5raW5kID09PSB0cy5TeW50YXhLaW5kLlN0cmluZ0xpdGVyYWw7XG59XG5cbmZ1bmN0aW9uIGxhc3ROb2RlV2l0aChub2RlczogdHMuTm9kZVtdLCBwcmVkaWNhdGU6IChub2RlOiB0cy5Ob2RlKSA9PiBib29sZWFuKTogdHMuTm9kZXxudWxsIHtcbiAgZm9yIChsZXQgaSA9IG5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGNvbW1lbnQgdGV4dCByYW5nZXMgYmVmb3JlIGFuZCBhZnRlciBhIG5vZGVcbiAqIGludG8gdHMuU3ludGhlc2l6ZWRDb21tZW50cyBmb3IgdGhlIG5vZGUgYW5kIHByZXZlbnQgdGhlXG4gKiBjb21tZW50IHRleHQgcmFuZ2VzIHRvIGJlIGVtaXR0ZWQsIHRvIGFsbG93XG4gKiBjaGFuZ2luZyB0aGVzZSBjb21tZW50cy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgdmlzaXRvciB0byBiZSBhYmxlIHRvIGRvIHNvbWVcbiAqIHN0YXRlIG1hbmFnZW1lbnQgYWZ0ZXIgdGhlIGNhbGxlciBpcyBkb25lIGNoYW5naW5nIGEgbm9kZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZpc2l0Tm9kZVdpdGhTeW50aGVzaXplZENvbW1lbnRzPFQgZXh0ZW5kcyB0cy5Ob2RlPihcbiAgICBjb250ZXh0OiB0cy5UcmFuc2Zvcm1hdGlvbkNvbnRleHQsIHNvdXJjZUZpbGU6IHRzLlNvdXJjZUZpbGUsIG5vZGU6IFQsXG4gICAgdmlzaXRvcjogKG5vZGU6IFQpID0+IFQpOiBUIHtcbiAgaWYgKG5vZGUuZmxhZ3MgJiB0cy5Ob2RlRmxhZ3MuU3ludGhlc2l6ZWQpIHtcbiAgICByZXR1cm4gdmlzaXRvcihub2RlKTtcbiAgfVxuICBpZiAobm9kZS5raW5kID09PSB0cy5TeW50YXhLaW5kLkJsb2NrKSB7XG4gICAgY29uc3QgYmxvY2sgPSBub2RlIGFzIHRzLk5vZGUgYXMgdHMuQmxvY2s7XG4gICAgbm9kZSA9IHZpc2l0Tm9kZVN0YXRlbWVudHNXaXRoU3ludGhlc2l6ZWRDb21tZW50cyhcbiAgICAgICAgY29udGV4dCwgc291cmNlRmlsZSwgbm9kZSwgYmxvY2suc3RhdGVtZW50cyxcbiAgICAgICAgKG5vZGUsIHN0bXRzKSA9PiB2aXNpdG9yKHRzLnVwZGF0ZUJsb2NrKGJsb2NrLCBzdG10cykgYXMgdHMuTm9kZSBhcyBUKSk7XG4gIH0gZWxzZSBpZiAobm9kZS5raW5kID09PSB0cy5TeW50YXhLaW5kLlNvdXJjZUZpbGUpIHtcbiAgICBub2RlID0gdmlzaXROb2RlU3RhdGVtZW50c1dpdGhTeW50aGVzaXplZENvbW1lbnRzKFxuICAgICAgICBjb250ZXh0LCBzb3VyY2VGaWxlLCBub2RlLCBzb3VyY2VGaWxlLnN0YXRlbWVudHMsXG4gICAgICAgIChub2RlLCBzdG10cykgPT4gdmlzaXRvcih1cGRhdGVTb3VyY2VGaWxlTm9kZShzb3VyY2VGaWxlLCBzdG10cykgYXMgdHMuTm9kZSBhcyBUKSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZmlsZUNvbnRleHQgPSBhc3NlcnRGaWxlQ29udGV4dChjb250ZXh0LCBzb3VyY2VGaWxlKTtcbiAgICBjb25zdCBsZWFkaW5nTGFzdENvbW1lbnRFbmQgPVxuICAgICAgICBzeW50aGVzaXplTGVhZGluZ0NvbW1lbnRzKHNvdXJjZUZpbGUsIG5vZGUsIGZpbGVDb250ZXh0Lmxhc3RDb21tZW50RW5kKTtcbiAgICBjb25zdCB0cmFpbGluZ0xhc3RDb21tZW50RW5kID0gc3ludGhlc2l6ZVRyYWlsaW5nQ29tbWVudHMoc291cmNlRmlsZSwgbm9kZSk7XG4gICAgaWYgKGxlYWRpbmdMYXN0Q29tbWVudEVuZCAhPT0gLTEpIHtcbiAgICAgIGZpbGVDb250ZXh0Lmxhc3RDb21tZW50RW5kID0gbGVhZGluZ0xhc3RDb21tZW50RW5kO1xuICAgIH1cbiAgICBub2RlID0gdmlzaXRvcihub2RlKTtcbiAgICBpZiAodHJhaWxpbmdMYXN0Q29tbWVudEVuZCAhPT0gLTEpIHtcbiAgICAgIGZpbGVDb250ZXh0Lmxhc3RDb21tZW50RW5kID0gdHJhaWxpbmdMYXN0Q29tbWVudEVuZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc2V0Tm9kZVRleHRSYW5nZVRvUHJldmVudER1cGxpY2F0ZUNvbW1lbnRzKG5vZGUpO1xufVxuXG4vKipcbiAqIFJlc2V0IHRoZSB0ZXh0IHJhbmdlIGZvciBzb21lIHNwZWNpYWwgbm9kZXMgYXMgb3RoZXJ3aXNlIFR5cGVTY3JpcHRcbiAqIHdvdWxkIGFsd2F5cyBlbWl0IHRoZSBvcmlnaW5hbCBjb21tZW50cyBmb3IgdGhlbS5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzE3NTk0XG4gKlxuICogQHBhcmFtIG5vZGVcbiAqL1xuZnVuY3Rpb24gcmVzZXROb2RlVGV4dFJhbmdlVG9QcmV2ZW50RHVwbGljYXRlQ29tbWVudHM8VCBleHRlbmRzIHRzLk5vZGU+KG5vZGU6IFQpOiBUIHtcbiAgdHMuc2V0RW1pdEZsYWdzKG5vZGUsICh0cy5nZXRFbWl0RmxhZ3Mobm9kZSkgfHwgMCkgfCB0cy5FbWl0RmxhZ3MuTm9Db21tZW50cyk7XG4gIC8vIFNlZSBhbHNvIGVtaXRNaXNzaW5nU3ludGhldGljQ29tbWVudHNBZnRlclR5cGVzY3JpcHRUcmFuc2Zvcm0uXG4gIC8vIE5vdGU6IERvbid0IHJlc2V0IHRoZSB0ZXh0UmFuZ2UgZm9yIHRzLkV4cG9ydERlY2xhcmF0aW9uIC8gdHMuSW1wb3J0RGVjbGFyYXRpb25cbiAgLy8gdW50aWwgYWZ0ZXIgdGhlIFR5cGVTY3JpcHQgdHJhbnNmb3JtZXIgYXMgd2UgbmVlZCB0aGUgc291cmNlIGxvY2F0aW9uXG4gIC8vIHRvIG1hcCB0aGUgZ2VuZXJhdGVkIGByZXF1aXJlYCBjYWxscyBiYWNrIHRvIHRoZSBvcmlnaW5hbFxuICAvLyB0cy5FeHBvcnREZWNsYXJhdGlvbiAvIHRzLkltcG9ydERlY2xhcmF0aW9uIG5vZGVzLlxuICBsZXQgYWxsb3dUZXh0UmFuZ2UgPSBub2RlLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuQ2xhc3NEZWNsYXJhdGlvbiAmJlxuICAgICAgbm9kZS5raW5kICE9PSB0cy5TeW50YXhLaW5kLlZhcmlhYmxlRGVjbGFyYXRpb24gJiZcbiAgICAgICEobm9kZS5raW5kID09PSB0cy5TeW50YXhLaW5kLlZhcmlhYmxlU3RhdGVtZW50ICYmXG4gICAgICAgIGhhc01vZGlmaWVyRmxhZyhub2RlLCB0cy5Nb2RpZmllckZsYWdzLkV4cG9ydCkpO1xuICBpZiAobm9kZS5raW5kID09PSB0cy5TeW50YXhLaW5kLlByb3BlcnR5RGVjbGFyYXRpb24pIHtcbiAgICBhbGxvd1RleHRSYW5nZSA9IGZhbHNlO1xuICAgIGNvbnN0IHBkID0gbm9kZSBhcyB0cy5Ob2RlIGFzIHRzLlByb3BlcnR5RGVjbGFyYXRpb247XG4gICAgbm9kZSA9IHRzLnVwZGF0ZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgcGQsIHBkLmRlY29yYXRvcnMsIHBkLm1vZGlmaWVycywgcmVzZXRUZXh0UmFuZ2UocGQubmFtZSkgYXMgdHMuUHJvcGVydHlOYW1lLFxuICAgICAgICAgICAgICAgcGQucXVlc3Rpb25Ub2tlbiwgcGQudHlwZSwgcGQuaW5pdGlhbGl6ZXIpIGFzIHRzLk5vZGUgYXMgVDtcbiAgfVxuICBpZiAoIWFsbG93VGV4dFJhbmdlKSB7XG4gICAgbm9kZSA9IHJlc2V0VGV4dFJhbmdlKG5vZGUpO1xuICB9XG4gIHJldHVybiBub2RlO1xuXG4gIGZ1bmN0aW9uIHJlc2V0VGV4dFJhbmdlPFQgZXh0ZW5kcyB0cy5Ob2RlPihub2RlOiBUKTogVCB7XG4gICAgaWYgKCEobm9kZS5mbGFncyAmIHRzLk5vZGVGbGFncy5TeW50aGVzaXplZCkpIHtcbiAgICAgIC8vIG5lZWQgdG8gY2xvbmUgYXMgd2UgZG9uJ3Qgd2FudCB0byBtb2RpZnkgc291cmNlIG5vZGVzLFxuICAgICAgLy8gYXMgdGhlIHBhcnNlZCBTb3VyY2VGaWxlcyBjb3VsZCBiZSBjYWNoZWQhXG4gICAgICBub2RlID0gdHMuZ2V0TXV0YWJsZUNsb25lKG5vZGUpO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0UmFuZ2UgPSB7cG9zOiBub2RlLnBvcywgZW5kOiBub2RlLmVuZH07XG4gICAgdHMuc2V0U291cmNlTWFwUmFuZ2Uobm9kZSwgdGV4dFJhbmdlKTtcbiAgICB0cy5zZXRUZXh0UmFuZ2Uobm9kZSwge3BvczogLTEsIGVuZDogLTF9KTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufVxuXG4vKipcbiAqIFJlYWRzIGluIHRoZSBsZWFkaW5nIGNvbW1lbnQgdGV4dCByYW5nZXMgb2YgdGhlIGdpdmVuIG5vZGUsXG4gKiBjb252ZXJ0cyB0aGVtIGludG8gYHRzLlN5bnRoZXRpY0NvbW1lbnRgcyBhbmQgc3RvcmVzIHRoZW0gb24gdGhlIG5vZGUuXG4gKlxuICogTm90ZTogVGhpcyB3b3VsZCBiZSBncmVhdGx5IHNpbXBsaWZpZWQgd2l0aCBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzE3NjE1LlxuICpcbiAqIEBwYXJhbSBsYXN0Q29tbWVudEVuZCBUaGUgZW5kIG9mIHRoZSBsYXN0IGNvbW1lbnRcbiAqIEByZXR1cm4gVGhlIGVuZCBvZiB0aGUgbGFzdCBmb3VuZCBjb21tZW50LCAtMSBpZiBubyBjb21tZW50IHdhcyBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gc3ludGhlc2l6ZUxlYWRpbmdDb21tZW50cyhcbiAgICBzb3VyY2VGaWxlOiB0cy5Tb3VyY2VGaWxlLCBub2RlOiB0cy5Ob2RlLCBsYXN0Q29tbWVudEVuZDogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gIGNvbnN0IHNoYXJlc1N0YXJ0V2l0aFBhcmVudCA9IHBhcmVudCAmJiBwYXJlbnQua2luZCAhPT0gdHMuU3ludGF4S2luZC5CbG9jayAmJlxuICAgICAgcGFyZW50LmtpbmQgIT09IHRzLlN5bnRheEtpbmQuU291cmNlRmlsZSAmJiBwYXJlbnQuZ2V0RnVsbFN0YXJ0KCkgPT09IG5vZGUuZ2V0RnVsbFN0YXJ0KCk7XG4gIGlmIChzaGFyZXNTdGFydFdpdGhQYXJlbnQgfHwgbGFzdENvbW1lbnRFbmQgPj0gbm9kZS5nZXRTdGFydCgpKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGNvbnN0IGFkanVzdGVkTm9kZUZ1bGxTdGFydCA9IE1hdGgubWF4KGxhc3RDb21tZW50RW5kLCBub2RlLmdldEZ1bGxTdGFydCgpKTtcbiAgY29uc3QgbGVhZGluZ0NvbW1lbnRzID1cbiAgICAgIGdldEFsbExlYWRpbmdDb21tZW50UmFuZ2VzKHNvdXJjZUZpbGUsIGFkanVzdGVkTm9kZUZ1bGxTdGFydCwgbm9kZS5nZXRTdGFydCgpKTtcbiAgaWYgKGxlYWRpbmdDb21tZW50cyAmJiBsZWFkaW5nQ29tbWVudHMubGVuZ3RoKSB7XG4gICAgdHMuc2V0U3ludGhldGljTGVhZGluZ0NvbW1lbnRzKG5vZGUsIHN5bnRoZXNpemVDb21tZW50UmFuZ2VzKHNvdXJjZUZpbGUsIGxlYWRpbmdDb21tZW50cykpO1xuICAgIHJldHVybiBub2RlLmdldFN0YXJ0KCk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFJlYWRzIGluIHRoZSB0cmFpbGluZyBjb21tZW50IHRleHQgcmFuZ2VzIG9mIHRoZSBnaXZlbiBub2RlLFxuICogY29udmVydHMgdGhlbSBpbnRvIGB0cy5TeW50aGV0aWNDb21tZW50YHMgYW5kIHN0b3JlcyB0aGVtIG9uIHRoZSBub2RlLlxuICpcbiAqIE5vdGU6IFRoaXMgd291bGQgYmUgZ3JlYXRseSBzaW1wbGlmaWVkIHdpdGggaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xNzYxNS5cbiAqXG4gKiBAcmV0dXJuIFRoZSBlbmQgb2YgdGhlIGxhc3QgZm91bmQgY29tbWVudCwgLTEgaWYgbm8gY29tbWVudCB3YXMgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIHN5bnRoZXNpemVUcmFpbGluZ0NvbW1lbnRzKHNvdXJjZUZpbGU6IHRzLlNvdXJjZUZpbGUsIG5vZGU6IHRzLk5vZGUpOiBudW1iZXIge1xuICBjb25zdCBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgY29uc3Qgc2hhcmVzRW5kV2l0aFBhcmVudCA9IHBhcmVudCAmJiBwYXJlbnQua2luZCAhPT0gdHMuU3ludGF4S2luZC5CbG9jayAmJlxuICAgICAgcGFyZW50LmtpbmQgIT09IHRzLlN5bnRheEtpbmQuU291cmNlRmlsZSAmJiBwYXJlbnQuZ2V0RW5kKCkgPT09IG5vZGUuZ2V0RW5kKCk7XG4gIGlmIChzaGFyZXNFbmRXaXRoUGFyZW50KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGNvbnN0IHRyYWlsaW5nQ29tbWVudHMgPSB0cy5nZXRUcmFpbGluZ0NvbW1lbnRSYW5nZXMoc291cmNlRmlsZS50ZXh0LCBub2RlLmdldEVuZCgpKTtcbiAgaWYgKHRyYWlsaW5nQ29tbWVudHMgJiYgdHJhaWxpbmdDb21tZW50cy5sZW5ndGgpIHtcbiAgICB0cy5zZXRTeW50aGV0aWNUcmFpbGluZ0NvbW1lbnRzKG5vZGUsIHN5bnRoZXNpemVDb21tZW50UmFuZ2VzKHNvdXJjZUZpbGUsIHRyYWlsaW5nQ29tbWVudHMpKTtcbiAgICByZXR1cm4gdHJhaWxpbmdDb21tZW50c1t0cmFpbGluZ0NvbW1lbnRzLmxlbmd0aCAtIDFdLmVuZDtcbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIGFycmF5T2Y8VD4odmFsdWU6IFR8dW5kZWZpbmVkfG51bGwpOiBUW10ge1xuICByZXR1cm4gdmFsdWUgPyBbdmFsdWVdIDogW107XG59XG5cbi8qKlxuICogQ29udmVydCBsZWFkaW5nL3RyYWlsaW5nIGRldGFjaGVkIGNvbW1lbnQgcmFuZ2VzIG9mIHN0YXRlbWVudCBhcnJheXNcbiAqIChlLmcuIHRoZSBzdGF0ZW1lbnRzIG9mIGEgdHMuU291cmNlRmlsZSBvciB0cy5CbG9jaykgaW50b1xuICogYHRzLk5vbkVtaXR0ZWRTdGF0ZW1lbnRgcyB3aXRoIGB0cy5TeW50aGVzaXplZENvbW1lbnRgcyBhbmRcbiAqIHByZXBlbmRzIC8gYXBwZW5kcyB0aGVtIHRvIHRoZSBnaXZlbiBzdGF0ZW1lbnQgYXJyYXkuXG4gKiBUaGlzIGlzIG5lZWRlZCB0byBhbGxvdyBjaGFuZ2luZyB0aGVzZSBjb21tZW50cy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgdmlzaXRvciB0byBiZSBhYmxlIHRvIGRvIHNvbWVcbiAqIHN0YXRlIG1hbmFnZW1lbnQgYWZ0ZXIgdGhlIGNhbGxlciBpcyBkb25lIGNoYW5naW5nIGEgbm9kZS5cbiAqL1xuZnVuY3Rpb24gdmlzaXROb2RlU3RhdGVtZW50c1dpdGhTeW50aGVzaXplZENvbW1lbnRzPFQgZXh0ZW5kcyB0cy5Ob2RlPihcbiAgICBjb250ZXh0OiB0cy5UcmFuc2Zvcm1hdGlvbkNvbnRleHQsIHNvdXJjZUZpbGU6IHRzLlNvdXJjZUZpbGUsIG5vZGU6IFQsXG4gICAgc3RhdGVtZW50czogdHMuTm9kZUFycmF5PHRzLlN0YXRlbWVudD4sXG4gICAgdmlzaXRvcjogKG5vZGU6IFQsIHN0YXRlbWVudHM6IHRzLk5vZGVBcnJheTx0cy5TdGF0ZW1lbnQ+KSA9PiBUKTogVCB7XG4gIGNvbnN0IGxlYWRpbmcgPSBzeW50aGVzaXplRGV0YWNoZWRMZWFkaW5nQ29tbWVudHMoc291cmNlRmlsZSwgbm9kZSwgc3RhdGVtZW50cyk7XG4gIGNvbnN0IHRyYWlsaW5nID0gc3ludGhlc2l6ZURldGFjaGVkVHJhaWxpbmdDb21tZW50cyhzb3VyY2VGaWxlLCBub2RlLCBzdGF0ZW1lbnRzKTtcbiAgaWYgKGxlYWRpbmcuY29tbWVudFN0bXQgfHwgdHJhaWxpbmcuY29tbWVudFN0bXQpIHtcbiAgICBjb25zdCBuZXdTdGF0ZW1lbnRzOiB0cy5TdGF0ZW1lbnRbXSA9XG4gICAgICAgIFsuLi5hcnJheU9mKGxlYWRpbmcuY29tbWVudFN0bXQpLCAuLi5zdGF0ZW1lbnRzLCAuLi5hcnJheU9mKHRyYWlsaW5nLmNvbW1lbnRTdG10KV07XG4gICAgc3RhdGVtZW50cyA9IHRzLnNldFRleHRSYW5nZSh0cy5jcmVhdGVOb2RlQXJyYXkobmV3U3RhdGVtZW50cyksIHtwb3M6IC0xLCBlbmQ6IC0xfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmlzaXRvciBjcmVhdGVzIGEgbmV3IG5vZGUgd2l0aCB0aGUgbmV3IHN0YXRlbWVudHMuIEhvd2V2ZXIsIGRvaW5nIHNvXG4gICAgICogcmV2ZWFscyBhIFR5cGVTY3JpcHQgYnVnLlxuICAgICAqIFRvIHJlcHJvZHVjZSBjb21tZW50IG91dCB0aGUgbGluZSBiZWxvdyBhbmQgY29tcGlsZTpcbiAgICAgKlxuICAgICAqIC8vIC4uLi4uLlxuICAgICAqXG4gICAgICogYWJzdHJhY3QgY2xhc3MgQSB7XG4gICAgICogfVxuICAgICAqIGFic3RyYWN0IGNsYXNzIEIgZXh0ZW5kcyBBIHtcbiAgICAgKiAgIC8vIC4uLi4uLlxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBuZXdsaW5lcyBhcmUgc2lnbmlmaWNhbnQuIFRoaXMgd291bGQgcmVzdWx0IGluIHRoZSBmb2xsb3dpbmc6XG4gICAgICogcnVudGltZSBlcnJvciBcIlR5cGVFcnJvcjogQ2Fubm90IHJlYWQgcHJvcGVydHkgJ21lbWJlcnMnIG9mIHVuZGVmaW5lZFwiLlxuICAgICAqXG4gICAgICogVGhlIGxpbmUgYmVsb3cgaXMgYSB3b3JrYXJvdW5kIHRoYXQgZW5zdXJlcyB0aGF0IHVwZGF0ZVNvdXJjZUZpbGVOb2RlIGFuZFxuICAgICAqIHVwZGF0ZUJsb2NrIG5ldmVyIGNyZWF0ZSBuZXcgTm9kZXMuXG4gICAgICogVE9ETygjNjM0KTogZmlsZSBhIGJ1ZyB3aXRoIFRTIHRlYW0uXG4gICAgICovXG4gICAgKG5vZGUgYXMgdHMuTm9kZSBhcyB0cy5Tb3VyY2VGaWxlKS5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcblxuICAgIGNvbnN0IGZpbGVDb250ZXh0ID0gYXNzZXJ0RmlsZUNvbnRleHQoY29udGV4dCwgc291cmNlRmlsZSk7XG4gICAgaWYgKGxlYWRpbmcubGFzdENvbW1lbnRFbmQgIT09IC0xKSB7XG4gICAgICBmaWxlQ29udGV4dC5sYXN0Q29tbWVudEVuZCA9IGxlYWRpbmcubGFzdENvbW1lbnRFbmQ7XG4gICAgfVxuICAgIG5vZGUgPSB2aXNpdG9yKG5vZGUsIHN0YXRlbWVudHMpO1xuICAgIGlmICh0cmFpbGluZy5sYXN0Q29tbWVudEVuZCAhPT0gLTEpIHtcbiAgICAgIGZpbGVDb250ZXh0Lmxhc3RDb21tZW50RW5kID0gdHJhaWxpbmcubGFzdENvbW1lbnRFbmQ7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHJldHVybiB2aXNpdG9yKG5vZGUsIHN0YXRlbWVudHMpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgbGVhZGluZyBkZXRhY2hlZCBjb21tZW50IHJhbmdlcyBvZiBzdGF0ZW1lbnQgYXJyYXlzXG4gKiAoZS5nLiB0aGUgc3RhdGVtZW50cyBvZiBhIHRzLlNvdXJjZUZpbGUgb3IgdHMuQmxvY2spIGludG8gYVxuICogYHRzLk5vbkVtaXR0ZWRTdGF0ZW1lbnRgIHdpdGggYHRzLlN5bnRoZXNpemVkQ29tbWVudGBzLlxuICpcbiAqIEEgRGV0YWNoZWQgbGVhZGluZyBjb21tZW50IGlzIHRoZSBmaXJzdCBjb21tZW50IGluIGEgU291cmNlRmlsZSAvIEJsb2NrXG4gKiB0aGF0IGlzIHNlcGFyYXRlZCB3aXRoIGEgbmV3bGluZSBmcm9tIHRoZSBmaXJzdCBzdGF0ZW1lbnQuXG4gKlxuICogTm90ZTogVGhpcyB3b3VsZCBiZSBncmVhdGx5IHNpbXBsaWZpZWQgd2l0aCBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzE3NjE1LlxuICovXG5mdW5jdGlvbiBzeW50aGVzaXplRGV0YWNoZWRMZWFkaW5nQ29tbWVudHMoXG4gICAgc291cmNlRmlsZTogdHMuU291cmNlRmlsZSwgbm9kZTogdHMuTm9kZSwgc3RhdGVtZW50czogdHMuTm9kZUFycmF5PHRzLlN0YXRlbWVudD4pOlxuICAgIHtjb21tZW50U3RtdDogdHMuU3RhdGVtZW50fG51bGwsIGxhc3RDb21tZW50RW5kOiBudW1iZXJ9IHtcbiAgbGV0IHRyaXZpYUVuZCA9IHN0YXRlbWVudHMuZW5kO1xuICBpZiAoc3RhdGVtZW50cy5sZW5ndGgpIHtcbiAgICB0cml2aWFFbmQgPSBzdGF0ZW1lbnRzWzBdLmdldFN0YXJ0KCk7XG4gIH1cbiAgY29uc3QgZGV0YWNoZWRDb21tZW50cyA9IGdldERldGFjaGVkTGVhZGluZ0NvbW1lbnRSYW5nZXMoc291cmNlRmlsZSwgc3RhdGVtZW50cy5wb3MsIHRyaXZpYUVuZCk7XG4gIGlmICghZGV0YWNoZWRDb21tZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4ge2NvbW1lbnRTdG10OiBudWxsLCBsYXN0Q29tbWVudEVuZDogLTF9O1xuICB9XG4gIGNvbnN0IGxhc3RDb21tZW50RW5kID0gZGV0YWNoZWRDb21tZW50c1tkZXRhY2hlZENvbW1lbnRzLmxlbmd0aCAtIDFdLmVuZDtcbiAgY29uc3QgY29tbWVudFN0bXQgPSBjcmVhdGVOb3RFbWl0dGVkU3RhdGVtZW50KHNvdXJjZUZpbGUpO1xuICB0cy5zZXRTeW50aGV0aWNUcmFpbGluZ0NvbW1lbnRzKFxuICAgICAgY29tbWVudFN0bXQsIHN5bnRoZXNpemVDb21tZW50UmFuZ2VzKHNvdXJjZUZpbGUsIGRldGFjaGVkQ29tbWVudHMpKTtcbiAgcmV0dXJuIHtjb21tZW50U3RtdCwgbGFzdENvbW1lbnRFbmR9O1xufVxuXG4vKipcbiAqIENvbnZlcnQgdHJhaWxpbmcgZGV0YWNoZWQgY29tbWVudCByYW5nZXMgb2Ygc3RhdGVtZW50IGFycmF5c1xuICogKGUuZy4gdGhlIHN0YXRlbWVudHMgb2YgYSB0cy5Tb3VyY2VGaWxlIG9yIHRzLkJsb2NrKSBpbnRvIGFcbiAqIGB0cy5Ob25FbWl0dGVkU3RhdGVtZW50YCB3aXRoIGB0cy5TeW50aGVzaXplZENvbW1lbnRgcy5cbiAqXG4gKiBBIERldGFjaGVkIHRyYWlsaW5nIGNvbW1lbnQgYXJlIGFsbCBjb21tZW50cyBhZnRlciB0aGUgZmlyc3QgbmV3bGluZVxuICogdGhlIGZvbGxvd3MgdGhlIGxhc3Qgc3RhdGVtZW50IGluIGEgU291cmNlRmlsZSAvIEJsb2NrLlxuICpcbiAqIE5vdGU6IFRoaXMgd291bGQgYmUgZ3JlYXRseSBzaW1wbGlmaWVkIHdpdGggaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xNzYxNS5cbiAqL1xuZnVuY3Rpb24gc3ludGhlc2l6ZURldGFjaGVkVHJhaWxpbmdDb21tZW50cyhcbiAgICBzb3VyY2VGaWxlOiB0cy5Tb3VyY2VGaWxlLCBub2RlOiB0cy5Ob2RlLCBzdGF0ZW1lbnRzOiB0cy5Ob2RlQXJyYXk8dHMuU3RhdGVtZW50Pik6XG4gICAge2NvbW1lbnRTdG10OiB0cy5TdGF0ZW1lbnR8bnVsbCwgbGFzdENvbW1lbnRFbmQ6IG51bWJlcn0ge1xuICBsZXQgdHJhaWxpbmdDb21tZW50U3RhcnQgPSBzdGF0ZW1lbnRzLmVuZDtcbiAgaWYgKHN0YXRlbWVudHMubGVuZ3RoKSB7XG4gICAgY29uc3QgbGFzdFN0bXQgPSBzdGF0ZW1lbnRzW3N0YXRlbWVudHMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgbGFzdFN0bXRUcmFpbGluZ0NvbW1lbnRzID0gdHMuZ2V0VHJhaWxpbmdDb21tZW50UmFuZ2VzKHNvdXJjZUZpbGUudGV4dCwgbGFzdFN0bXQuZW5kKTtcbiAgICBpZiAobGFzdFN0bXRUcmFpbGluZ0NvbW1lbnRzICYmIGxhc3RTdG10VHJhaWxpbmdDb21tZW50cy5sZW5ndGgpIHtcbiAgICAgIHRyYWlsaW5nQ29tbWVudFN0YXJ0ID0gbGFzdFN0bXRUcmFpbGluZ0NvbW1lbnRzW2xhc3RTdG10VHJhaWxpbmdDb21tZW50cy5sZW5ndGggLSAxXS5lbmQ7XG4gICAgfVxuICB9XG4gIGNvbnN0IGRldGFjaGVkQ29tbWVudHMgPSBnZXRBbGxMZWFkaW5nQ29tbWVudFJhbmdlcyhzb3VyY2VGaWxlLCB0cmFpbGluZ0NvbW1lbnRTdGFydCwgbm9kZS5lbmQpO1xuICBpZiAoIWRldGFjaGVkQ29tbWVudHMgfHwgIWRldGFjaGVkQ29tbWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHtjb21tZW50U3RtdDogbnVsbCwgbGFzdENvbW1lbnRFbmQ6IC0xfTtcbiAgfVxuICBjb25zdCBsYXN0Q29tbWVudEVuZCA9IGRldGFjaGVkQ29tbWVudHNbZGV0YWNoZWRDb21tZW50cy5sZW5ndGggLSAxXS5lbmQ7XG4gIGNvbnN0IGNvbW1lbnRTdG10ID0gY3JlYXRlTm90RW1pdHRlZFN0YXRlbWVudChzb3VyY2VGaWxlKTtcbiAgdHMuc2V0U3ludGhldGljTGVhZGluZ0NvbW1lbnRzKFxuICAgICAgY29tbWVudFN0bXQsIHN5bnRoZXNpemVDb21tZW50UmFuZ2VzKHNvdXJjZUZpbGUsIGRldGFjaGVkQ29tbWVudHMpKTtcbiAgcmV0dXJuIHtjb21tZW50U3RtdCwgbGFzdENvbW1lbnRFbmR9O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHRoZSBkZXRhY2hlZCBsZWFkaW5nIGNvbW1lbnQgcmFuZ2VzIGluIGFuIGFyZWEgb2YgYSBTb3VyY2VGaWxlLlxuICogQHBhcmFtIHNvdXJjZUZpbGUgVGhlIHNvdXJjZSBmaWxlXG4gKiBAcGFyYW0gc3RhcnQgV2hlcmUgdG8gc3RhcnQgc2Nhbm5pbmdcbiAqIEBwYXJhbSBlbmQgV2hlcmUgdG8gZW5kIHNjYW5uaW5nXG4gKi9cbi8vIE5vdGU6IFRoaXMgY29kZSBpcyBiYXNlZCBvbiBjb21waWxlci9jb21tZW50cy50cyBpbiBUeXBlU2NyaXB0XG5mdW5jdGlvbiBnZXREZXRhY2hlZExlYWRpbmdDb21tZW50UmFuZ2VzKFxuICAgIHNvdXJjZUZpbGU6IHRzLlNvdXJjZUZpbGUsIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKTogdHMuQ29tbWVudFJhbmdlW10ge1xuICBjb25zdCBsZWFkaW5nQ29tbWVudHMgPSBnZXRBbGxMZWFkaW5nQ29tbWVudFJhbmdlcyhzb3VyY2VGaWxlLCBzdGFydCwgZW5kKTtcbiAgaWYgKCFsZWFkaW5nQ29tbWVudHMgfHwgIWxlYWRpbmdDb21tZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgZGV0YWNoZWRDb21tZW50czogdHMuQ29tbWVudFJhbmdlW10gPSBbXTtcbiAgbGV0IGxhc3RDb21tZW50OiB0cy5Db21tZW50UmFuZ2V8dW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG4gIGZvciAoY29uc3QgY29tbWVudCBvZiBsZWFkaW5nQ29tbWVudHMpIHtcbiAgICBpZiAobGFzdENvbW1lbnQpIHtcbiAgICAgIGNvbnN0IGxhc3RDb21tZW50TGluZSA9IGdldExpbmVPZlBvcyhzb3VyY2VGaWxlLCBsYXN0Q29tbWVudC5lbmQpO1xuICAgICAgY29uc3QgY29tbWVudExpbmUgPSBnZXRMaW5lT2ZQb3Moc291cmNlRmlsZSwgY29tbWVudC5wb3MpO1xuXG4gICAgICBpZiAoY29tbWVudExpbmUgPj0gbGFzdENvbW1lbnRMaW5lICsgMikge1xuICAgICAgICAvLyBUaGVyZSB3YXMgYSBibGFuayBsaW5lIGJldHdlZW4gdGhlIGxhc3QgY29tbWVudCBhbmQgdGhpcyBjb21tZW50LiAgVGhpc1xuICAgICAgICAvLyBjb21tZW50IGlzIG5vdCBwYXJ0IG9mIHRoZSBjb3B5cmlnaHQgY29tbWVudHMuICBSZXR1cm4gd2hhdCB3ZSBoYXZlIHNvXG4gICAgICAgIC8vIGZhci5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGV0YWNoZWRDb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgIGxhc3RDb21tZW50ID0gY29tbWVudDtcbiAgfVxuXG4gIGlmIChkZXRhY2hlZENvbW1lbnRzLmxlbmd0aCkge1xuICAgIC8vIEFsbCBjb21tZW50cyBsb29rIGxpa2UgdGhleSBjb3VsZCBoYXZlIGJlZW4gcGFydCBvZiB0aGUgY29weXJpZ2h0IGhlYWRlci4gIE1ha2VcbiAgICAvLyBzdXJlIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBibGFuayBsaW5lIGJldHdlZW4gaXQgYW5kIHRoZSBub2RlLiAgSWYgbm90LCBpdCdzIG5vdFxuICAgIC8vIGEgY29weXJpZ2h0IGhlYWRlci5cbiAgICBjb25zdCBsYXN0Q29tbWVudExpbmUgPVxuICAgICAgICBnZXRMaW5lT2ZQb3Moc291cmNlRmlsZSwgZGV0YWNoZWRDb21tZW50c1tkZXRhY2hlZENvbW1lbnRzLmxlbmd0aCAtIDFdLmVuZCk7XG4gICAgY29uc3Qgbm9kZUxpbmUgPSBnZXRMaW5lT2ZQb3Moc291cmNlRmlsZSwgZW5kKTtcbiAgICBpZiAobm9kZUxpbmUgPj0gbGFzdENvbW1lbnRMaW5lICsgMikge1xuICAgICAgLy8gVmFsaWQgZGV0YWNoZWRDb21tZW50c1xuICAgICAgcmV0dXJuIGRldGFjaGVkQ29tbWVudHM7XG4gICAgfVxuICB9XG4gIHJldHVybiBbXTtcbn1cblxuZnVuY3Rpb24gZ2V0TGluZU9mUG9zKHNvdXJjZUZpbGU6IHRzLlNvdXJjZUZpbGUsIHBvczogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIHRzLmdldExpbmVBbmRDaGFyYWN0ZXJPZlBvc2l0aW9uKHNvdXJjZUZpbGUsIHBvcykubGluZTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdHMuQ29tbWVudFJhbmdlYHMgaW50byBgdHMuU3ludGhlc2l6ZWRDb21tZW50YHNcbiAqIEBwYXJhbSBzb3VyY2VGaWxlXG4gKiBAcGFyYW0gcGFyc2VkQ29tbWVudHNcbiAqL1xuZnVuY3Rpb24gc3ludGhlc2l6ZUNvbW1lbnRSYW5nZXMoXG4gICAgc291cmNlRmlsZTogdHMuU291cmNlRmlsZSwgcGFyc2VkQ29tbWVudHM6IHRzLkNvbW1lbnRSYW5nZVtdKTogdHMuU3ludGhlc2l6ZWRDb21tZW50W10ge1xuICBjb25zdCBzeW50aGVzaXplZENvbW1lbnRzOiB0cy5TeW50aGVzaXplZENvbW1lbnRbXSA9IFtdO1xuICBwYXJzZWRDb21tZW50cy5mb3JFYWNoKCh7a2luZCwgcG9zLCBlbmQsIGhhc1RyYWlsaW5nTmV3TGluZX0sIGNvbW1lbnRJZHgpID0+IHtcbiAgICBsZXQgY29tbWVudFRleHQgPSBzb3VyY2VGaWxlLnRleHQuc3Vic3RyaW5nKHBvcywgZW5kKS50cmltKCk7XG4gICAgaWYgKGtpbmQgPT09IHRzLlN5bnRheEtpbmQuTXVsdGlMaW5lQ29tbWVudFRyaXZpYSkge1xuICAgICAgY29tbWVudFRleHQgPSBjb21tZW50VGV4dC5yZXBsYWNlKC8oXlxcL1xcKil8KFxcKlxcLyQpL2csICcnKTtcbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IHRzLlN5bnRheEtpbmQuU2luZ2xlTGluZUNvbW1lbnRUcml2aWEpIHtcbiAgICAgIGlmIChjb21tZW50VGV4dC5zdGFydHNXaXRoKCcvLy8nKSkge1xuICAgICAgICAvLyB0cmlwcGxlLXNsYXNoIGNvbW1lbnRzIGFyZSB0eXBlc2NyaXB0IHNwZWNpZmljLCBpZ25vcmUgdGhlbSBpbiB0aGUgb3V0cHV0LlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb21tZW50VGV4dCA9IGNvbW1lbnRUZXh0LnJlcGxhY2UoLyheXFwvXFwvKS9nLCAnJyk7XG4gICAgfVxuICAgIHN5bnRoZXNpemVkQ29tbWVudHMucHVzaCh7a2luZCwgdGV4dDogY29tbWVudFRleHQsIGhhc1RyYWlsaW5nTmV3TGluZSwgcG9zOiAtMSwgZW5kOiAtMX0pO1xuICB9KTtcbiAgcmV0dXJuIHN5bnRoZXNpemVkQ29tbWVudHM7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5vbiBlbWl0dGVkIHN0YXRlbWVudCB0aGF0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIHN5bnRoZXNpemVkIGNvbW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTm90RW1pdHRlZFN0YXRlbWVudChzb3VyY2VGaWxlOiB0cy5Tb3VyY2VGaWxlKTogdHMuTm90RW1pdHRlZFN0YXRlbWVudCB7XG4gIGNvbnN0IHN0bXQgPSB0cy5jcmVhdGVOb3RFbWl0dGVkU3RhdGVtZW50KHNvdXJjZUZpbGUpO1xuICB0cy5zZXRPcmlnaW5hbE5vZGUoc3RtdCwgdW5kZWZpbmVkKTtcbiAgdHMuc2V0VGV4dFJhbmdlKHN0bXQsIHtwb3M6IDAsIGVuZDogMH0pO1xuICB0cy5zZXRFbWl0RmxhZ3Moc3RtdCwgdHMuRW1pdEZsYWdzLkN1c3RvbVByb2xvZ3VlKTtcbiAgcmV0dXJuIHN0bXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbGVhZGluZyBjb21tZW50IHJhbmdlcyBpbiB0aGUgc291cmNlIGZpbGUgdGhhdCBzdGFydCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gKiBUaGlzIGlzIHRoZSBzYW1lIGFzIGB0cy5nZXRMZWFkaW5nQ29tbWVudFJhbmdlc2AsIGV4Y2VwdCB0aGF0IGl0IGRvZXMgbm90IHNraXBcbiAqIGNvbW1lbnRzIGJlZm9yZSB0aGUgZmlyc3QgbmV3bGluZSBpbiB0aGUgcmFuZ2UuXG4gKlxuICogQHBhcmFtIHNvdXJjZUZpbGVcbiAqIEBwYXJhbSBzdGFydCBXaGVyZSB0byBzdGFydCBzY2FubmluZ1xuICogQHBhcmFtIGVuZCBXaGVyZSB0byBlbmQgc2Nhbm5pbmdcbiAqL1xuZnVuY3Rpb24gZ2V0QWxsTGVhZGluZ0NvbW1lbnRSYW5nZXMoXG4gICAgc291cmNlRmlsZTogdHMuU291cmNlRmlsZSwgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpOiB0cy5Db21tZW50UmFuZ2VbXSB7XG4gIC8vIGV4ZXV0ZSB0cy5nZXRMZWFkaW5nQ29tbWVudFJhbmdlcyB3aXRoIHBvcyA9IDAgc28gdGhhdCBpdCBkb2VzIG5vdCBza2lwXG4gIC8vIGNvbW1lbnRzIHVudGlsIHRoZSBmaXJzdCBuZXdsaW5lLlxuICBjb25zdCBjb21tZW50UmFuZ2VzID0gdHMuZ2V0TGVhZGluZ0NvbW1lbnRSYW5nZXMoc291cmNlRmlsZS50ZXh0LnN1YnN0cmluZyhzdGFydCwgZW5kKSwgMCkgfHwgW107XG4gIHJldHVybiBjb21tZW50UmFuZ2VzLm1hcChjciA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNUcmFpbGluZ05ld0xpbmU6IGNyLmhhc1RyYWlsaW5nTmV3TGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogY3Iua2luZCBhcyBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogY3IucG9zICsgc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogY3IuZW5kICsgc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGEgdmVyc2lvbiBvZiBgdHMudmlzaXRFYWNoQ2hpbGRgIHRoYXQgd29ya3MgdGhhdCBjYWxscyBvdXIgdmVyc2lvblxuICogb2YgYHVwZGF0ZVNvdXJjZUZpbGVOb2RlYCwgc28gdGhhdCB0eXBlc2NyaXB0IGRvZXNuJ3QgbG9zZSB0eXBlIGluZm9ybWF0aW9uXG4gKiBmb3IgcHJvcGVydHkgZGVjb3JhdG9ycy5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzE3Mzg0XG4gKlxuICogQHBhcmFtIHNmXG4gKiBAcGFyYW0gc3RhdGVtZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gdmlzaXRFYWNoQ2hpbGQoXG4gICAgbm9kZTogdHMuTm9kZSwgdmlzaXRvcjogdHMuVmlzaXRvciwgY29udGV4dDogdHMuVHJhbnNmb3JtYXRpb25Db250ZXh0KTogdHMuTm9kZSB7XG4gIGlmIChub2RlLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuU291cmNlRmlsZSkge1xuICAgIGNvbnN0IHNmID0gbm9kZSBhcyB0cy5Tb3VyY2VGaWxlO1xuICAgIHJldHVybiB1cGRhdGVTb3VyY2VGaWxlTm9kZShzZiwgdHMudmlzaXRMZXhpY2FsRW52aXJvbm1lbnQoc2Yuc3RhdGVtZW50cywgdmlzaXRvciwgY29udGV4dCkpO1xuICB9XG5cbiAgcmV0dXJuIHRzLnZpc2l0RWFjaENoaWxkKG5vZGUsIHZpc2l0b3IsIGNvbnRleHQpO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgYSB2ZXJzaW9uIG9mIGB0cy51cGRhdGVTb3VyY2VGaWxlTm9kZWAgdGhhdCB3b3Jrc1xuICogd2VsbCB3aXRoIHByb3BlcnR5IGRlY29yYXRvcnMuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xNzM4NFxuICogVE9ETygjNjM0KTogVGhpcyBoYXMgYmVlbiBmaXhlZCBpbiBUUyAyLjUuIEludmVzdGlnYXRlIHJlbW92YWwuXG4gKlxuICogQHBhcmFtIHNmXG4gKiBAcGFyYW0gc3RhdGVtZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlU291cmNlRmlsZU5vZGUoXG4gICAgc2Y6IHRzLlNvdXJjZUZpbGUsIHN0YXRlbWVudHM6IHRzLk5vZGVBcnJheTx0cy5TdGF0ZW1lbnQ+KTogdHMuU291cmNlRmlsZSB7XG4gIGlmIChzdGF0ZW1lbnRzID09PSBzZi5zdGF0ZW1lbnRzKSB7XG4gICAgcmV0dXJuIHNmO1xuICB9XG4gIC8vIE5vdGU6IE5lZWQgdG8gY2xvbmUgdGhlIG9yaWdpbmFsIGZpbGUgKGFuZCBub3QgdXNlIGB0cy51cGRhdGVTb3VyY2VGaWxlTm9kZWApXG4gIC8vIGFzIG90aGVyd2lzZSBUUyBmYWlscyB3aGVuIHJlc29sdmluZyB0eXBlcyBmb3IgZGVjb3JhdG9ycy5cbiAgc2YgPSB0cy5nZXRNdXRhYmxlQ2xvbmUoc2YpO1xuICBzZi5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgcmV0dXJuIHNmO1xufVxuXG4vLyBDb3BpZWQgZnJvbSBUeXBlU2NyaXB0XG5leHBvcnQgZnVuY3Rpb24gaXNUeXBlTm9kZUtpbmQoa2luZDogdHMuU3ludGF4S2luZCkge1xuICByZXR1cm4gKGtpbmQgPj0gdHMuU3ludGF4S2luZC5GaXJzdFR5cGVOb2RlICYmIGtpbmQgPD0gdHMuU3ludGF4S2luZC5MYXN0VHlwZU5vZGUpIHx8XG4gICAgICBraW5kID09PSB0cy5TeW50YXhLaW5kLkFueUtleXdvcmQgfHwga2luZCA9PT0gdHMuU3ludGF4S2luZC5OdW1iZXJLZXl3b3JkIHx8XG4gICAgICBraW5kID09PSB0cy5TeW50YXhLaW5kLk9iamVjdEtleXdvcmQgfHwga2luZCA9PT0gdHMuU3ludGF4S2luZC5Cb29sZWFuS2V5d29yZCB8fFxuICAgICAga2luZCA9PT0gdHMuU3ludGF4S2luZC5TdHJpbmdLZXl3b3JkIHx8IGtpbmQgPT09IHRzLlN5bnRheEtpbmQuU3ltYm9sS2V5d29yZCB8fFxuICAgICAga2luZCA9PT0gdHMuU3ludGF4S2luZC5UaGlzS2V5d29yZCB8fCBraW5kID09PSB0cy5TeW50YXhLaW5kLlZvaWRLZXl3b3JkIHx8XG4gICAgICBraW5kID09PSB0cy5TeW50YXhLaW5kLlVuZGVmaW5lZEtleXdvcmQgfHwga2luZCA9PT0gdHMuU3ludGF4S2luZC5OdWxsS2V5d29yZCB8fFxuICAgICAga2luZCA9PT0gdHMuU3ludGF4S2luZC5OZXZlcktleXdvcmQgfHwga2luZCA9PT0gdHMuU3ludGF4S2luZC5FeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHM7XG59XG4iXX0=