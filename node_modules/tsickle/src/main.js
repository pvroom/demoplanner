#!/usr/bin/env node
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/main", ["require", "exports", "fs", "minimist", "mkdirp", "path", "tsickle/src/typescript", "tsickle/src/cli_support", "tsickle/src/tsickle", "tsickle/src/tsickle", "tsickle/src/util"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs = require("fs");
    var minimist = require("minimist");
    var mkdirp = require("mkdirp");
    var path = require("path");
    var ts = require("tsickle/src/typescript");
    var cliSupport = require("tsickle/src/cli_support");
    var tsickle = require("tsickle/src/tsickle");
    var tsickle_1 = require("tsickle/src/tsickle");
    var util_1 = require("tsickle/src/util");
    function usage() {
        console.error("usage: tsickle [tsickle options] -- [tsc options]\n\nexample:\n  tsickle --externs=foo/externs.js -- -p src --noImplicitAny\n\ntsickle flags are:\n  --externs=PATH        save generated Closure externs.js to PATH\n  --typed               [experimental] attempt to provide Closure types instead of {?}\n  --disableAutoQuoting  do not automatically apply quotes to property accesses\n");
    }
    /**
     * Parses the command-line arguments, extracting the tsickle settings and
     * the arguments to pass on to tsc.
     */
    function loadSettingsFromArgs(args) {
        var settings = {};
        var parsedArgs = minimist(args);
        try {
            for (var _a = __values(Object.keys(parsedArgs)), _b = _a.next(); !_b.done; _b = _a.next()) {
                var flag = _b.value;
                switch (flag) {
                    case 'h':
                    case 'help':
                        usage();
                        process.exit(0);
                        break;
                    case 'externs':
                        settings.externsPath = parsedArgs[flag];
                        break;
                    case 'typed':
                        settings.isTyped = true;
                        break;
                    case 'verbose':
                        settings.verbose = true;
                        break;
                    case 'disableAutoQuoting':
                        settings.disableAutoQuoting = true;
                        break;
                    case '_':
                        // This is part of the minimist API, and holds args after the '--'.
                        break;
                    default:
                        console.error("unknown flag '--" + flag + "'");
                        usage();
                        process.exit(1);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // Arguments after the '--' arg are arguments to tsc.
        var tscArgs = parsedArgs['_'];
        return { settings: settings, tscArgs: tscArgs };
        var e_1, _c;
    }
    /**
     * Loads the tsconfig.json from a directory.
     *
     * TODO(martinprobst): use ts.findConfigFile to match tsc behaviour.
     *
     * @param args tsc command-line arguments.
     */
    function loadTscConfig(args) {
        // Gather tsc options/input files from command line.
        var _a = ts.parseCommandLine(args), options = _a.options, fileNames = _a.fileNames, errors = _a.errors;
        if (errors.length > 0) {
            return { options: {}, fileNames: [], errors: errors };
        }
        // Store file arguments
        var tsFileArguments = fileNames;
        // Read further settings from tsconfig.json.
        var projectDir = options.project || '.';
        var configFileName = path.join(projectDir, 'tsconfig.json');
        var _b = ts.readConfigFile(configFileName, function (path) { return fs.readFileSync(path, 'utf-8'); }), json = _b.config, error = _b.error;
        if (error) {
            return { options: {}, fileNames: [], errors: [error] };
        }
        (_c = ts.parseJsonConfigFileContent(json, ts.sys, projectDir, options, configFileName), options = _c.options, fileNames = _c.fileNames, errors = _c.errors);
        if (errors.length > 0) {
            return { options: {}, fileNames: [], errors: errors };
        }
        // if file arguments were given to the typescript transpiler then transpile only those files
        fileNames = tsFileArguments.length > 0 ? tsFileArguments : fileNames;
        return { options: options, fileNames: fileNames, errors: [] };
        var _c;
    }
    /**
     * Compiles TypeScript code into Closure-compiler-ready JS.
     */
    function toClosureJS(options, fileNames, settings, writeFile) {
        // Use absolute paths to determine what files to process since files may be imported using
        // relative or absolute paths
        var absoluteFileNames = fileNames.map(function (i) { return path.resolve(i); });
        var compilerHost = ts.createCompilerHost(options);
        var program = ts.createProgram(fileNames, options, compilerHost);
        var filesToProcess = new Set(absoluteFileNames);
        var rootModulePath = options.rootDir || util_1.getCommonParentDirectory(absoluteFileNames);
        var transformerHost = {
            shouldSkipTsickleProcessing: function (fileName) {
                return !filesToProcess.has(path.resolve(fileName));
            },
            shouldIgnoreWarningsForPath: function (fileName) { return false; },
            pathToModuleName: cliSupport.pathToModuleName.bind(null, rootModulePath),
            fileNameToModuleId: function (fileName) { return fileName; },
            es5Mode: true,
            googmodule: true,
            prelude: '',
            transformDecorators: true,
            transformTypesToClosure: true,
            typeBlackListPaths: new Set(),
            disableAutoQuoting: settings.disableAutoQuoting,
            untyped: false,
            logWarning: function (warning) { return console.error(tsickle.formatDiagnostics([warning])); },
            options: options,
            host: compilerHost,
        };
        var diagnostics = ts.getPreEmitDiagnostics(program);
        if (diagnostics.length > 0) {
            return {
                diagnostics: diagnostics,
                modulesManifest: new tsickle_1.ModulesManifest(),
                externs: {},
                emitSkipped: true,
                emittedFiles: [],
            };
        }
        return tsickle.emitWithTsickle(program, transformerHost, compilerHost, options, undefined, writeFile);
    }
    exports.toClosureJS = toClosureJS;
    function main(args) {
        var _a = loadSettingsFromArgs(args), settings = _a.settings, tscArgs = _a.tscArgs;
        var config = loadTscConfig(tscArgs);
        if (config.errors.length) {
            console.error(tsickle.formatDiagnostics(config.errors));
            return 1;
        }
        if (config.options.module !== ts.ModuleKind.CommonJS) {
            // This is not an upstream TypeScript diagnostic, therefore it does not go
            // through the diagnostics array mechanism.
            console.error('tsickle converts TypeScript modules to Closure modules via CommonJS internally. ' +
                'Set tsconfig.js "module": "commonjs"');
            return 1;
        }
        // Run tsickle+TSC to convert inputs to Closure JS files.
        var result = toClosureJS(config.options, config.fileNames, settings, function (filePath, contents) {
            mkdirp.sync(path.dirname(filePath));
            fs.writeFileSync(filePath, contents, { encoding: 'utf-8' });
        });
        if (result.diagnostics.length) {
            console.error(tsickle.formatDiagnostics(result.diagnostics));
            return 1;
        }
        if (settings.externsPath) {
            mkdirp.sync(path.dirname(settings.externsPath));
            fs.writeFileSync(settings.externsPath, tsickle.getGeneratedExterns(result.externs));
        }
        return 0;
    }
    // CLI entry point
    if (require.main === module) {
        process.exit(main(process.argv.splice(2)));
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9tYWluLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFVQSx1QkFBeUI7SUFDekIsbUNBQXFDO0lBQ3JDLCtCQUFpQztJQUNqQywyQkFBNkI7SUFDN0IsMkNBQW1DO0lBRW5DLG9EQUE0QztJQUM1Qyw2Q0FBcUM7SUFDckMsK0NBQTBDO0lBQzFDLHlDQUFnRDtJQWlCaEQ7UUFDRSxPQUFPLENBQUMsS0FBSyxDQUFDLGdZQVNmLENBQUMsQ0FBQztJQUNILENBQUM7SUFFRDs7O09BR0c7SUFDSCw4QkFBOEIsSUFBYztRQUMxQyxJQUFNLFFBQVEsR0FBYSxFQUFFLENBQUM7UUFDOUIsSUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDOztZQUNsQyxLQUFtQixJQUFBLEtBQUEsU0FBQSxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFBLGdCQUFBO2dCQUFyQyxJQUFNLElBQUksV0FBQTtnQkFDYixRQUFRLElBQUksRUFBRTtvQkFDWixLQUFLLEdBQUcsQ0FBQztvQkFDVCxLQUFLLE1BQU07d0JBQ1QsS0FBSyxFQUFFLENBQUM7d0JBQ1IsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFDaEIsTUFBTTtvQkFDUixLQUFLLFNBQVM7d0JBQ1osUUFBUSxDQUFDLFdBQVcsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7d0JBQ3hDLE1BQU07b0JBQ1IsS0FBSyxPQUFPO3dCQUNWLFFBQVEsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO3dCQUN4QixNQUFNO29CQUNSLEtBQUssU0FBUzt3QkFDWixRQUFRLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQzt3QkFDeEIsTUFBTTtvQkFDUixLQUFLLG9CQUFvQjt3QkFDdkIsUUFBUSxDQUFDLGtCQUFrQixHQUFHLElBQUksQ0FBQzt3QkFD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QUFRLENBQUMsV0FBVyxFQUFFO1lBQ3hCLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztZQUNoRCxFQUFFLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1NBQ3JGO1FBQ0QsT0FBTyxDQUFDLENBQUM7SUFDWCxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLElBQUksT0FBTyxDQUFDLElBQUksS0FBSyxNQUFNLEVBQUU7UUFDM0IsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQzVDIiwic291cmNlc0NvbnRlbnQiOlsiIyEvdXNyL2Jpbi9lbnYgbm9kZVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIG1pbmltaXN0IGZyb20gJ21pbmltaXN0JztcbmltcG9ydCAqIGFzIG1rZGlycCBmcm9tICdta2RpcnAnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIHRzIGZyb20gJy4vdHlwZXNjcmlwdCc7XG5cbmltcG9ydCAqIGFzIGNsaVN1cHBvcnQgZnJvbSAnLi9jbGlfc3VwcG9ydCc7XG5pbXBvcnQgKiBhcyB0c2lja2xlIGZyb20gJy4vdHNpY2tsZSc7XG5pbXBvcnQge01vZHVsZXNNYW5pZmVzdH0gZnJvbSAnLi90c2lja2xlJztcbmltcG9ydCB7Z2V0Q29tbW9uUGFyZW50RGlyZWN0b3J5fSBmcm9tICcuL3V0aWwnO1xuXG4vKiogVHNpY2tsZSBzZXR0aW5ncyBwYXNzZWQgb24gdGhlIGNvbW1hbmQgbGluZS4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2V0dGluZ3Mge1xuICAvKiogSWYgcHJvdmlkZWQsIGRvIG5vdCBtb2RpZnkgcXVvdGluZyBvZiBwcm9wZXJ0eSBhY2Nlc3Nlcy4gKi9cbiAgZGlzYWJsZUF1dG9RdW90aW5nPzogYm9vbGVhbjtcblxuICAvKiogSWYgcHJvdmlkZWQsIHBhdGggdG8gc2F2ZSBleHRlcm5zIHRvLiAqL1xuICBleHRlcm5zUGF0aD86IHN0cmluZztcblxuICAvKiogSWYgcHJvdmlkZWQsIGF0dGVtcHQgdG8gcHJvdmlkZSB0eXBlcyByYXRoZXIgdGhhbiB7P30uICovXG4gIGlzVHlwZWQ/OiBib29sZWFuO1xuXG4gIC8qKiBJZiB0cnVlLCBsb2cgaW50ZXJuYWwgZGVidWcgd2FybmluZ3MgdG8gdGhlIGNvbnNvbGUuICovXG4gIHZlcmJvc2U/OiBib29sZWFuO1xufVxuXG5mdW5jdGlvbiB1c2FnZSgpIHtcbiAgY29uc29sZS5lcnJvcihgdXNhZ2U6IHRzaWNrbGUgW3RzaWNrbGUgb3B0aW9uc10gLS0gW3RzYyBvcHRpb25zXVxuXG5leGFtcGxlOlxuICB0c2lja2xlIC0tZXh0ZXJucz1mb28vZXh0ZXJucy5qcyAtLSAtcCBzcmMgLS1ub0ltcGxpY2l0QW55XG5cbnRzaWNrbGUgZmxhZ3MgYXJlOlxuICAtLWV4dGVybnM9UEFUSCAgICAgICAgc2F2ZSBnZW5lcmF0ZWQgQ2xvc3VyZSBleHRlcm5zLmpzIHRvIFBBVEhcbiAgLS10eXBlZCAgICAgICAgICAgICAgIFtleHBlcmltZW50YWxdIGF0dGVtcHQgdG8gcHJvdmlkZSBDbG9zdXJlIHR5cGVzIGluc3RlYWQgb2Ygez99XG4gIC0tZGlzYWJsZUF1dG9RdW90aW5nICBkbyBub3QgYXV0b21hdGljYWxseSBhcHBseSBxdW90ZXMgdG8gcHJvcGVydHkgYWNjZXNzZXNcbmApO1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgY29tbWFuZC1saW5lIGFyZ3VtZW50cywgZXh0cmFjdGluZyB0aGUgdHNpY2tsZSBzZXR0aW5ncyBhbmRcbiAqIHRoZSBhcmd1bWVudHMgdG8gcGFzcyBvbiB0byB0c2MuXG4gKi9cbmZ1bmN0aW9uIGxvYWRTZXR0aW5nc0Zyb21BcmdzKGFyZ3M6IHN0cmluZ1tdKToge3NldHRpbmdzOiBTZXR0aW5ncywgdHNjQXJnczogc3RyaW5nW119IHtcbiAgY29uc3Qgc2V0dGluZ3M6IFNldHRpbmdzID0ge307XG4gIGNvbnN0IHBhcnNlZEFyZ3MgPSBtaW5pbWlzdChhcmdzKTtcbiAgZm9yIChjb25zdCBmbGFnIG9mIE9iamVjdC5rZXlzKHBhcnNlZEFyZ3MpKSB7XG4gICAgc3dpdGNoIChmbGFnKSB7XG4gICAgICBjYXNlICdoJzpcbiAgICAgIGNhc2UgJ2hlbHAnOlxuICAgICAgICB1c2FnZSgpO1xuICAgICAgICBwcm9jZXNzLmV4aXQoMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZXh0ZXJucyc6XG4gICAgICAgIHNldHRpbmdzLmV4dGVybnNQYXRoID0gcGFyc2VkQXJnc1tmbGFnXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0eXBlZCc6XG4gICAgICAgIHNldHRpbmdzLmlzVHlwZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3ZlcmJvc2UnOlxuICAgICAgICBzZXR0aW5ncy52ZXJib3NlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkaXNhYmxlQXV0b1F1b3RpbmcnOlxuICAgICAgICBzZXR0aW5ncy5kaXNhYmxlQXV0b1F1b3RpbmcgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ18nOlxuICAgICAgICAvLyBUaGlzIGlzIHBhcnQgb2YgdGhlIG1pbmltaXN0IEFQSSwgYW5kIGhvbGRzIGFyZ3MgYWZ0ZXIgdGhlICctLScuXG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS5lcnJvcihgdW5rbm93biBmbGFnICctLSR7ZmxhZ30nYCk7XG4gICAgICAgIHVzYWdlKCk7XG4gICAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICB9XG4gIH1cbiAgLy8gQXJndW1lbnRzIGFmdGVyIHRoZSAnLS0nIGFyZyBhcmUgYXJndW1lbnRzIHRvIHRzYy5cbiAgY29uc3QgdHNjQXJncyA9IHBhcnNlZEFyZ3NbJ18nXTtcbiAgcmV0dXJuIHtzZXR0aW5ncywgdHNjQXJnc307XG59XG5cbi8qKlxuICogTG9hZHMgdGhlIHRzY29uZmlnLmpzb24gZnJvbSBhIGRpcmVjdG9yeS5cbiAqXG4gKiBUT0RPKG1hcnRpbnByb2JzdCk6IHVzZSB0cy5maW5kQ29uZmlnRmlsZSB0byBtYXRjaCB0c2MgYmVoYXZpb3VyLlxuICpcbiAqIEBwYXJhbSBhcmdzIHRzYyBjb21tYW5kLWxpbmUgYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiBsb2FkVHNjQ29uZmlnKGFyZ3M6IHN0cmluZ1tdKTpcbiAgICB7b3B0aW9uczogdHMuQ29tcGlsZXJPcHRpb25zLCBmaWxlTmFtZXM6IHN0cmluZ1tdLCBlcnJvcnM6IHRzLkRpYWdub3N0aWNbXX0ge1xuICAvLyBHYXRoZXIgdHNjIG9wdGlvbnMvaW5wdXQgZmlsZXMgZnJvbSBjb21tYW5kIGxpbmUuXG4gIGxldCB7b3B0aW9ucywgZmlsZU5hbWVzLCBlcnJvcnN9ID0gdHMucGFyc2VDb21tYW5kTGluZShhcmdzKTtcbiAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHtvcHRpb25zOiB7fSwgZmlsZU5hbWVzOiBbXSwgZXJyb3JzfTtcbiAgfVxuXG4gIC8vIFN0b3JlIGZpbGUgYXJndW1lbnRzXG4gIGNvbnN0IHRzRmlsZUFyZ3VtZW50cyA9IGZpbGVOYW1lcztcblxuICAvLyBSZWFkIGZ1cnRoZXIgc2V0dGluZ3MgZnJvbSB0c2NvbmZpZy5qc29uLlxuICBjb25zdCBwcm9qZWN0RGlyID0gb3B0aW9ucy5wcm9qZWN0IHx8ICcuJztcbiAgY29uc3QgY29uZmlnRmlsZU5hbWUgPSBwYXRoLmpvaW4ocHJvamVjdERpciwgJ3RzY29uZmlnLmpzb24nKTtcbiAgY29uc3Qge2NvbmZpZzoganNvbiwgZXJyb3J9ID1cbiAgICAgIHRzLnJlYWRDb25maWdGaWxlKGNvbmZpZ0ZpbGVOYW1lLCBwYXRoID0+IGZzLnJlYWRGaWxlU3luYyhwYXRoLCAndXRmLTgnKSk7XG4gIGlmIChlcnJvcikge1xuICAgIHJldHVybiB7b3B0aW9uczoge30sIGZpbGVOYW1lczogW10sIGVycm9yczogW2Vycm9yXX07XG4gIH1cbiAgKHtvcHRpb25zLCBmaWxlTmFtZXMsIGVycm9yc30gPVxuICAgICAgIHRzLnBhcnNlSnNvbkNvbmZpZ0ZpbGVDb250ZW50KGpzb24sIHRzLnN5cywgcHJvamVjdERpciwgb3B0aW9ucywgY29uZmlnRmlsZU5hbWUpKTtcbiAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHtvcHRpb25zOiB7fSwgZmlsZU5hbWVzOiBbXSwgZXJyb3JzfTtcbiAgfVxuXG4gIC8vIGlmIGZpbGUgYXJndW1lbnRzIHdlcmUgZ2l2ZW4gdG8gdGhlIHR5cGVzY3JpcHQgdHJhbnNwaWxlciB0aGVuIHRyYW5zcGlsZSBvbmx5IHRob3NlIGZpbGVzXG4gIGZpbGVOYW1lcyA9IHRzRmlsZUFyZ3VtZW50cy5sZW5ndGggPiAwID8gdHNGaWxlQXJndW1lbnRzIDogZmlsZU5hbWVzO1xuXG4gIHJldHVybiB7b3B0aW9ucywgZmlsZU5hbWVzLCBlcnJvcnM6IFtdfTtcbn1cblxuLyoqXG4gKiBDb21waWxlcyBUeXBlU2NyaXB0IGNvZGUgaW50byBDbG9zdXJlLWNvbXBpbGVyLXJlYWR5IEpTLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9DbG9zdXJlSlMoXG4gICAgb3B0aW9uczogdHMuQ29tcGlsZXJPcHRpb25zLCBmaWxlTmFtZXM6IHN0cmluZ1tdLCBzZXR0aW5nczogU2V0dGluZ3MsXG4gICAgd3JpdGVGaWxlPzogdHMuV3JpdGVGaWxlQ2FsbGJhY2spOiB0c2lja2xlLkVtaXRSZXN1bHQge1xuICAvLyBVc2UgYWJzb2x1dGUgcGF0aHMgdG8gZGV0ZXJtaW5lIHdoYXQgZmlsZXMgdG8gcHJvY2VzcyBzaW5jZSBmaWxlcyBtYXkgYmUgaW1wb3J0ZWQgdXNpbmdcbiAgLy8gcmVsYXRpdmUgb3IgYWJzb2x1dGUgcGF0aHNcbiAgY29uc3QgYWJzb2x1dGVGaWxlTmFtZXMgPSBmaWxlTmFtZXMubWFwKGkgPT4gcGF0aC5yZXNvbHZlKGkpKTtcblxuICBjb25zdCBjb21waWxlckhvc3QgPSB0cy5jcmVhdGVDb21waWxlckhvc3Qob3B0aW9ucyk7XG4gIGNvbnN0IHByb2dyYW0gPSB0cy5jcmVhdGVQcm9ncmFtKGZpbGVOYW1lcywgb3B0aW9ucywgY29tcGlsZXJIb3N0KTtcbiAgY29uc3QgZmlsZXNUb1Byb2Nlc3MgPSBuZXcgU2V0KGFic29sdXRlRmlsZU5hbWVzKTtcbiAgY29uc3Qgcm9vdE1vZHVsZVBhdGggPSBvcHRpb25zLnJvb3REaXIgfHwgZ2V0Q29tbW9uUGFyZW50RGlyZWN0b3J5KGFic29sdXRlRmlsZU5hbWVzKTtcbiAgY29uc3QgdHJhbnNmb3JtZXJIb3N0OiB0c2lja2xlLlRzaWNrbGVIb3N0ID0ge1xuICAgIHNob3VsZFNraXBUc2lja2xlUHJvY2Vzc2luZzogKGZpbGVOYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgIHJldHVybiAhZmlsZXNUb1Byb2Nlc3MuaGFzKHBhdGgucmVzb2x2ZShmaWxlTmFtZSkpO1xuICAgIH0sXG4gICAgc2hvdWxkSWdub3JlV2FybmluZ3NGb3JQYXRoOiAoZmlsZU5hbWU6IHN0cmluZykgPT4gZmFsc2UsXG4gICAgcGF0aFRvTW9kdWxlTmFtZTogY2xpU3VwcG9ydC5wYXRoVG9Nb2R1bGVOYW1lLmJpbmQobnVsbCwgcm9vdE1vZHVsZVBhdGgpLFxuICAgIGZpbGVOYW1lVG9Nb2R1bGVJZDogKGZpbGVOYW1lKSA9PiBmaWxlTmFtZSxcbiAgICBlczVNb2RlOiB0cnVlLFxuICAgIGdvb2dtb2R1bGU6IHRydWUsXG4gICAgcHJlbHVkZTogJycsXG4gICAgdHJhbnNmb3JtRGVjb3JhdG9yczogdHJ1ZSxcbiAgICB0cmFuc2Zvcm1UeXBlc1RvQ2xvc3VyZTogdHJ1ZSxcbiAgICB0eXBlQmxhY2tMaXN0UGF0aHM6IG5ldyBTZXQoKSxcbiAgICBkaXNhYmxlQXV0b1F1b3Rpbmc6IHNldHRpbmdzLmRpc2FibGVBdXRvUXVvdGluZyxcbiAgICB1bnR5cGVkOiBmYWxzZSxcbiAgICBsb2dXYXJuaW5nOiAod2FybmluZykgPT4gY29uc29sZS5lcnJvcih0c2lja2xlLmZvcm1hdERpYWdub3N0aWNzKFt3YXJuaW5nXSkpLFxuICAgIG9wdGlvbnMsXG4gICAgaG9zdDogY29tcGlsZXJIb3N0LFxuICB9O1xuICBjb25zdCBkaWFnbm9zdGljcyA9IHRzLmdldFByZUVtaXREaWFnbm9zdGljcyhwcm9ncmFtKTtcbiAgaWYgKGRpYWdub3N0aWNzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGlhZ25vc3RpY3MsXG4gICAgICBtb2R1bGVzTWFuaWZlc3Q6IG5ldyBNb2R1bGVzTWFuaWZlc3QoKSxcbiAgICAgIGV4dGVybnM6IHt9LFxuICAgICAgZW1pdFNraXBwZWQ6IHRydWUsXG4gICAgICBlbWl0dGVkRmlsZXM6IFtdLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHRzaWNrbGUuZW1pdFdpdGhUc2lja2xlKFxuICAgICAgcHJvZ3JhbSwgdHJhbnNmb3JtZXJIb3N0LCBjb21waWxlckhvc3QsIG9wdGlvbnMsIHVuZGVmaW5lZCwgd3JpdGVGaWxlKTtcbn1cblxuZnVuY3Rpb24gbWFpbihhcmdzOiBzdHJpbmdbXSk6IG51bWJlciB7XG4gIGNvbnN0IHtzZXR0aW5ncywgdHNjQXJnc30gPSBsb2FkU2V0dGluZ3NGcm9tQXJncyhhcmdzKTtcbiAgY29uc3QgY29uZmlnID0gbG9hZFRzY0NvbmZpZyh0c2NBcmdzKTtcbiAgaWYgKGNvbmZpZy5lcnJvcnMubGVuZ3RoKSB7XG4gICAgY29uc29sZS5lcnJvcih0c2lja2xlLmZvcm1hdERpYWdub3N0aWNzKGNvbmZpZy5lcnJvcnMpKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIGlmIChjb25maWcub3B0aW9ucy5tb2R1bGUgIT09IHRzLk1vZHVsZUtpbmQuQ29tbW9uSlMpIHtcbiAgICAvLyBUaGlzIGlzIG5vdCBhbiB1cHN0cmVhbSBUeXBlU2NyaXB0IGRpYWdub3N0aWMsIHRoZXJlZm9yZSBpdCBkb2VzIG5vdCBnb1xuICAgIC8vIHRocm91Z2ggdGhlIGRpYWdub3N0aWNzIGFycmF5IG1lY2hhbmlzbS5cbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAndHNpY2tsZSBjb252ZXJ0cyBUeXBlU2NyaXB0IG1vZHVsZXMgdG8gQ2xvc3VyZSBtb2R1bGVzIHZpYSBDb21tb25KUyBpbnRlcm5hbGx5LiAnICtcbiAgICAgICAgJ1NldCB0c2NvbmZpZy5qcyBcIm1vZHVsZVwiOiBcImNvbW1vbmpzXCInKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8vIFJ1biB0c2lja2xlK1RTQyB0byBjb252ZXJ0IGlucHV0cyB0byBDbG9zdXJlIEpTIGZpbGVzLlxuICBjb25zdCByZXN1bHQgPSB0b0Nsb3N1cmVKUyhcbiAgICAgIGNvbmZpZy5vcHRpb25zLCBjb25maWcuZmlsZU5hbWVzLCBzZXR0aW5ncywgKGZpbGVQYXRoOiBzdHJpbmcsIGNvbnRlbnRzOiBzdHJpbmcpID0+IHtcbiAgICAgICAgbWtkaXJwLnN5bmMocGF0aC5kaXJuYW1lKGZpbGVQYXRoKSk7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMoZmlsZVBhdGgsIGNvbnRlbnRzLCB7ZW5jb2Rpbmc6ICd1dGYtOCd9KTtcbiAgICAgIH0pO1xuICBpZiAocmVzdWx0LmRpYWdub3N0aWNzLmxlbmd0aCkge1xuICAgIGNvbnNvbGUuZXJyb3IodHNpY2tsZS5mb3JtYXREaWFnbm9zdGljcyhyZXN1bHQuZGlhZ25vc3RpY3MpKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIGlmIChzZXR0aW5ncy5leHRlcm5zUGF0aCkge1xuICAgIG1rZGlycC5zeW5jKHBhdGguZGlybmFtZShzZXR0aW5ncy5leHRlcm5zUGF0aCkpO1xuICAgIGZzLndyaXRlRmlsZVN5bmMoc2V0dGluZ3MuZXh0ZXJuc1BhdGgsIHRzaWNrbGUuZ2V0R2VuZXJhdGVkRXh0ZXJucyhyZXN1bHQuZXh0ZXJucykpO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBDTEkgZW50cnkgcG9pbnRcbmlmIChyZXF1aXJlLm1haW4gPT09IG1vZHVsZSkge1xuICBwcm9jZXNzLmV4aXQobWFpbihwcm9jZXNzLmFyZ3Yuc3BsaWNlKDIpKSk7XG59XG4iXX0=