import { ElementRef, EventEmitter as NgEventEmitter } from '@angular/core';
export declare function outputs(instance: any, events: string[]): void;
export declare function inputs(instance: any, el: ElementRef, props: string[]): void;
export declare class App {
}
export declare class Avatar {
}
export declare class BackButton {
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`. For more information, see [Platform Styles](/docs/theming/platform-specific-styles).
     */
    mode: any;
    /**
     * The text property is used to provide custom text for the back button while using the default look-and-feel
     */
    text: any;
    icon: string;
    defaultHref: string;
    constructor(el: ElementRef);
}
export declare class Badge {
    /**
     * The color to use from your Sass `$colors` map. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information, see [Theming your App](/docs/theming/theming-your-app).
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`. For more information, see [Platform Styles](/docs/theming/platform-specific-styles).
     */
    mode: any;
    constructor(el: ElementRef);
}
export declare class Button {
    /**
     * The type of the button. Possible values are: `"submit"`, `"reset"` and `"button"`. Default value is: `"button"`
     */
    type: string;
    /**
     * Contains a URL or a URL fragment that the hyperlink points to. If this property is set, an anchor tag will be rendered.
     */
    href: string;
    /**
     * The type of button. Possible values are: `"button"`, `"bar-button"`.
     */
    buttonType: string;
    /**
     * The button size. Possible values are: `"small"`, `"default"`, `"large"`.
     */
    size: any;
    /**
     * If true, the user cannot interact with the button. Defaults to `false`.
     */
    disabled: boolean;
    /**
     * Set to `"clear"` for a transparent button, to `"outline"` for a transparent button with a border, or to `"solid"`. The default style is `"solid"` except inside of a toolbar, where the default is `"clear"`.
     */
    fill: any;
    /**
     * If true, activates a button with rounded corners.
     */
    round: boolean;
    /**
     * Set to `"block"` for a full-width button or to `"full"` for a full-width button without left and right borders.
     */
    expand: any;
    /**
     * If true, activates a button with a heavier font weight.
     */
    strong: boolean;
    /**
     * The color to use from your Sass `$colors` map. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information, see [Theming your App](/docs/theming/theming-your-app).
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`. For more information, see [Platform Styles](/docs/theming/platform-specific-styles).
     */
    mode: any;
    goBack: boolean;
    ionFocus: NgEventEmitter<any>;
    ionBlur: NgEventEmitter<any>;
    constructor(el: ElementRef);
}
export declare class Buttons {
}
export declare class Card {
    /**
     * The color to use for the background. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`.
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`.
     */
    mode: any;
    constructor(el: ElementRef);
}
export declare class CardContent {
    /**
     * The color to use for the text. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`.
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`.
     */
    mode: any;
    constructor(el: ElementRef);
}
export declare class CardHeader {
    /**
     * The color to use for the background. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`.
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`.
     */
    mode: any;
    /**
     * If true, the card header will be translucent. Defaults to `false`.
     */
    translucent: boolean;
    constructor(el: ElementRef);
}
export declare class CardSubtitle {
    /**
     * The color to use for the text color. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`.
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`.
     */
    mode: any;
    constructor(el: ElementRef);
}
export declare class CardTitle {
    /**
     * The color to use for the text color. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`.
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`.
     */
    mode: any;
    constructor(el: ElementRef);
}
export declare class Checkbox {
    /**
     * The color to use. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`.
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`.
     */
    mode: any;
    /**
     * The name of the control, which is submitted with the form data.
     */
    name: string;
    /**
     * If true, the checkbox is selected. Defaults to `false`.
     */
    checked: boolean;
    /**
     * If true, the user cannot interact with the checkbox. Defaults to `false`.
     */
    disabled: boolean;
    /**
     * the value of the checkbox.
     */
    value: string;
    ionChange: NgEventEmitter<any>;
    ionFocus: NgEventEmitter<any>;
    ionBlur: NgEventEmitter<any>;
    ionStyle: NgEventEmitter<any>;
    constructor(el: ElementRef);
}
export declare class Chip {
    /**
     * The color to use. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`.
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`.
     */
    mode: any;
    constructor(el: ElementRef);
}
export declare class ChipButton {
    /**
     * The color to use. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`.
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`.
     */
    mode: any;
    /**
     * If true, the user cannot interact with the chip button. Defaults to `false`.
     */
    disabled: boolean;
    /**
     * Set to `"clear"` for a transparent button style.
     */
    fill: string;
    /**
     * Contains a URL or a URL fragment that the hyperlink points to. If this property is set, an anchor tag will be rendered.
     */
    href: string;
    constructor(el: ElementRef);
}
export declare class Col {
}
export declare class Content {
    /**
     * If true, the content will scroll behind the headers and footers. This effect can easily be seen by setting the toolbar to transparent.
     */
    fullscreen: boolean;
    /**
     * If true and the content does not cause an overflow scroll, the scroll interaction will cause a bounce. If the content exceeds the bounds of ionContent, nothing will change. Note, the does not disable the system bounce on iOS. That is an OS level setting.
     */
    forceOverscroll: boolean;
    scrollEnabled: boolean;
    scrollEvents: boolean;
    constructor(el: ElementRef);
}
export declare class Datetime {
    /**
     * If true, the user cannot interact with the datetime. Defaults to `false`.
     */
    disabled: boolean;
    /**
     * The minimum datetime allowed. Value must be a date string following the [ISO 8601 datetime format standard](https://www.w3.org/TR/NOTE-datetime), such as `1996-12-19`. The format does not have to be specific to an exact datetime. For example, the minimum could just be the year, such as `1994`. Defaults to the beginning of the year, 100 years ago from today.
     */
    min: string;
    /**
     * The maximum datetime allowed. Value must be a date string following the [ISO 8601 datetime format standard](https://www.w3.org/TR/NOTE-datetime), `1996-12-19`. The format does not have to be specific to an exact datetime. For example, the maximum could just be the year, such as `1994`. Defaults to the end of this year.
     */
    max: string;
    /**
     * The display format of the date and time as text that shows within the item. When the `pickerFormat` input is not used, then the `displayFormat` is used for both display the formatted text, and determining the datetime picker's columns. See the `pickerFormat` input description for more info. Defaults to `MMM D, YYYY`.
     */
    displayFormat: string;
    /**
     * The format of the date and time picker columns the user selects. A datetime input can have one or many datetime parts, each getting their own column which allow individual selection of that particular datetime part. For example, year and month columns are two individually selectable columns which help choose an exact date from the datetime picker. Each column follows the string parse format. Defaults to use `displayFormat`.
     */
    pickerFormat: string;
    /**
     * The text to display on the picker's cancel button. Default: `Cancel`.
     */
    cancelText: string;
    /**
     * The text to display on the picker's "Done" button. Default: `Done`.
     */
    doneText: string;
    /**
     * Values used to create the list of selectable years. By default the year values range between the `min` and `max` datetime inputs. However, to control exactly which years to display, the `yearValues` input can take a number, an array of numbers, or string of comma separated numbers. For example, to show upcoming and recent leap years, then this input's value would be `yearValues="2024,2020,2016,2012,2008"`.
     */
    yearValues: any;
    /**
     * Values used to create the list of selectable months. By default the month values range from `1` to `12`. However, to control exactly which months to display, the `monthValues` input can take a number, an array of numbers, or a string of comma separated numbers. For example, if only summer months should be shown, then this input value would be `monthValues="6,7,8"`. Note that month numbers do *not* have a zero-based index, meaning January's value is `1`, and December's is `12`.
     */
    monthValues: any;
    /**
     * Values used to create the list of selectable days. By default every day is shown for the given month. However, to control exactly which days of the month to display, the `dayValues` input can take a number, an array of numbers, or a string of comma separated numbers. Note that even if the array days have an invalid number for the selected month, like `31` in February, it will correctly not show days which are not valid for the selected month.
     */
    dayValues: any;
    /**
     * Values used to create the list of selectable hours. By default the hour values range from `0` to `23` for 24-hour, or `1` to `12` for 12-hour. However, to control exactly which hours to display, the `hourValues` input can take a number, an array of numbers, or a string of comma separated numbers.
     */
    hourValues: any;
    /**
     * Values used to create the list of selectable minutes. By default the mintues range from `0` to `59`. However, to control exactly which minutes to display, the `minuteValues` input can take a number, an array of numbers, or a string of comma separated numbers. For example, if the minute selections should only be every 15 minutes, then this input value would be `minuteValues="0,15,30,45"`.
     */
    minuteValues: any;
    /**
     * Full names for each month name. This can be used to provide locale month names. Defaults to English.
     */
    monthNames: any;
    /**
     * Short abbreviated names for each month name. This can be used to provide locale month names. Defaults to English.
     */
    monthShortNames: any;
    /**
     * Full day of the week names. This can be used to provide locale names for each day in the week. Defaults to English.
     */
    dayNames: any;
    /**
     * Short abbreviated day of the week names. This can be used to provide locale names for each day in the week. Defaults to English.
     */
    dayShortNames: any;
    /**
     * Any additional options that the picker interface can accept. See the [Picker API docs](../../picker/Picker) for the picker options.
     */
    pickerOptions: any;
    /**
     * The text to display when there's no date selected yet. Using lowercase to match the input attribute
     */
    placeholder: string;
    /**
     * the value of the datetime.
     */
    value: string;
    ionCancel: NgEventEmitter<any>;
    ionStyle: NgEventEmitter<any>;
    constructor(el: ElementRef);
}
export declare class Fab {
    /**
     * Where to align the fab horizontally in the viewport. Possible values are: `"left"`, `"right"`, `"center"`, `"start"`, `"end"`.
     */
    horizontal: any;
    /**
     * Where to align the fab vertically in the viewport. Possible values are: `"top"`, `"center"`, `"bottom"`.
     */
    vertical: any;
    /**
     * If true, the fab will display on the edge of the header if `vertical` is `"top"`, and on the edge of the footer if it is `"bottom"`. Should be used with a `fixed` slot.
     */
    edge: boolean;
    constructor(el: ElementRef);
}
export declare class FabButton {
    /**
     * The color to use from your Sass `$colors` map. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information, see [Theming your App](/docs/theming/theming-your-app).
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`. For more information, see [Platform Styles](/docs/theming/platform-specific-styles).
     */
    mode: any;
    /**
     * If true, the fab button will be show a close icon. Defaults to `false`.
     */
    activated: boolean;
    /**
     * If true, the user cannot interact with the fab button. Defaults to `false`.
     */
    disabled: boolean;
    /**
     * Contains a URL or a URL fragment that the hyperlink points to. If this property is set, an anchor tag will be rendered.
     */
    href: string;
    /**
     * If true, the fab button will be translucent. Defaults to `false`.
     */
    translucent: boolean;
    toggleActive: any;
    show: boolean;
    constructor(el: ElementRef);
}
export declare class FabList {
    /**
     * If true, the fab list will be show all fab buttons in the list. Defaults to `false`.
     */
    activated: boolean;
    /**
     * The side the fab list will show on relative to the main fab button. Defaults to `'bottom'`.
     */
    side: any;
    constructor(el: ElementRef);
}
export declare class Footer {
    /**
     * If true, the footer will be translucent. Note: In order to scroll content behind the footer, the `fullscreen` attribute needs to be set on the content. Defaults to `false`.
     */
    translucent: boolean;
    constructor(el: ElementRef);
}
export declare class Grid {
}
export declare class Header {
    /**
     * If true, the header will be translucent. Note: In order to scroll content behind the header, the `fullscreen` attribute needs to be set on the content. Defaults to `false`.
     */
    translucent: boolean;
    constructor(el: ElementRef);
}
export declare class HideWhen {
    orientation: string;
    mediaQuery: string;
    size: string;
    mode: string;
    platform: string;
    or: boolean;
    constructor(el: ElementRef);
}
export declare class InfiniteScroll {
    /**
     * The threshold distance from the bottom of the content to call the `infinite` output event when scrolled. The threshold value can be either a percent, or in pixels. For example, use the value of `10%` for the `infinite` output event to get called when the user has scrolled 10% from the bottom of the page. Use the value `100px` when the scroll is within 100 pixels from the bottom of the page. Defaults to `15%`.
     */
    threshold: string;
    /**
     * If true, the infinite scroll will be hidden and scroll event listeners will be removed.  Call `enable(false)` to disable the infinite scroll from actively trying to receive new data while scrolling. This method is useful when it is known that there is no more data that can be added, and the infinite scroll is no longer needed.
     */
    disabled: boolean;
    /**
     * The position of the infinite scroll element. The value can be either `top` or `bottom`. Defaults to `bottom`.
     */
    position: string;
    ionInfinite: NgEventEmitter<any>;
    constructor(el: ElementRef);
}
export declare class InfiniteScrollContent {
    /**
     * An animated SVG spinner that shows while loading.
     */
    loadingSpinner: string;
    /**
     * Optional text to display while loading.
     */
    loadingText: string;
    constructor(el: ElementRef);
}
export declare class Input {
    /**
     * If the value of the type attribute is `"file"`, then this attribute will indicate the types of files that the server accepts, otherwise it will be ignored. The value must be a comma-separated list of unique content type specifiers.
     */
    accept: string;
    /**
     * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user. Defaults to `"none"`.
     */
    autocapitalize: string;
    /**
     * Indicates whether the value of the control can be automatically completed by the browser. Defaults to `"off"`.
     */
    autocomplete: string;
    /**
     * Whether autocorrection should be enabled when the user is entering/editing the text value. Defaults to `"off"`.
     */
    autocorrect: string;
    /**
     * This Boolean attribute lets you specify that a form control should have input focus when the page loads. Defaults to `false`.
     */
    autofocus: boolean;
    /**
     * If true and the type is `checkbox` or `radio`, the control is selected by default. Defaults to `false`.
     */
    checked: boolean;
    /**
     * If true, a clear icon will appear in the input when there is a value. Clicking it clears the input. Defaults to `false`.
     */
    clearInput: boolean;
    /**
     * If true, the value will be cleared after focus upon edit. Defaults to `true` when `type` is `"password"`, `false` for all other types.
     */
    clearOnEdit: boolean;
    /**
     * Set the amount of time, in milliseconds, to wait to trigger the `ionInput` event after each keystroke. Default `0`.
     */
    debounce: number;
    /**
     * If true, the user cannot interact with the input. Defaults to `false`.
     */
    disabled: boolean;
    /**
     * A hint to the browser for which keyboard to display. This attribute applies when the value of the type attribute is `"text"`, `"password"`, `"email"`, or `"url"`. Possible values are: `"verbatim"`, `"latin"`, `"latin-name"`, `"latin-prose"`, `"full-width-latin"`, `"kana"`, `"katakana"`, `"numeric"`, `"tel"`, `"email"`, `"url"`.
     */
    inputmode: string;
    /**
     * The maximum value, which must not be less than its minimum (min attribute) value.
     */
    max: string;
    /**
     * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the maximum number of characters that the user can enter.
     */
    maxlength: number;
    /**
     * The minimum value, which must not be greater than its maximum (max attribute) value.
     */
    min: string;
    /**
     * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the minimum number of characters that the user can enter.
     */
    minlength: number;
    /**
     * If true, the user can enter more than one value. This attribute applies when the type attribute is set to `"email"` or `"file"`, otherwise it is ignored.
     */
    multiple: boolean;
    /**
     * The name of the control, which is submitted with the form data.
     */
    name: string;
    /**
     * A regular expression that the value is checked against. The pattern must match the entire value, not just some subset. Use the title attribute to describe the pattern to help the user. This attribute applies when the value of the type attribute is `"text"`, `"search"`, `"tel"`, `"url"`, `"email"`, or `"password"`, otherwise it is ignored.
     */
    pattern: string;
    /**
     * Instructional text that shows before the input has a value.
     */
    placeholder: string;
    /**
     * If true, the user cannot modify the value. Defaults to `false`.
     */
    readonly: boolean;
    /**
     * If true, the user must fill in a value before submitting a form.
     */
    required: boolean;
    /**
     * This is a nonstandard attribute supported by Safari that only applies when the type is `"search"`. Its value should be a nonnegative decimal integer.
     */
    results: number;
    /**
     * If true, the element will have its spelling and grammar checked. Defaults to `false`.
     */
    spellcheck: boolean;
    /**
     * Works with the min and max attributes to limit the increments at which a value can be set. Possible values are: `"any"` or a positive floating point number.
     */
    step: string;
    /**
     * The initial size of the control. This value is in pixels unless the value of the type attribute is `"text"` or `"password"`, in which case it is an integer number of characters. This attribute applies only when the `type` attribute is set to `"text"`, `"search"`, `"tel"`, `"url"`, `"email"`, or `"password"`, otherwise it is ignored.
     */
    size: number;
    /**
     * The type of control to display. The default type is text. Possible values are: `"text"`, `"password"`, `"email"`, `"number"`, `"search"`, `"tel"`, or `"url"`.
     */
    type: string;
    /**
     * The value of the input.
     */
    value: string;
    ionInput: NgEventEmitter<any>;
    ionStyle: NgEventEmitter<any>;
    ionBlur: NgEventEmitter<any>;
    ionFocus: NgEventEmitter<any>;
    ionInputDidLoad: NgEventEmitter<any>;
    ionInputDidUnload: NgEventEmitter<any>;
    constructor(el: ElementRef);
}
export declare class Item {
    /**
     * The color to use from your Sass `$colors` map. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information, see [Theming your App](/docs/theming/theming-your-app).
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`. For more information, see [Platform Styles](/docs/theming/platform-specific-styles).
     */
    mode: any;
    /**
     * If true, a detail arrow will appear on the item. Defaults to `false` unless the `mode` is `ios` and an `href`, `onclick` or `button` property is present.
     */
    detail: boolean;
    /**
     * If true, the user cannot interact with the item. Defaults to `false`.
     */
    disabled: boolean;
    /**
     * Contains a URL or a URL fragment that the hyperlink points to. If this property is set, an anchor tag will be rendered.
     */
    href: string;
    /**
     * Whether or not this item should be tappable. If true, a button tag will be rendered. Defaults to `false`.
     */
    button: boolean;
    goBack: boolean;
    constructor(el: ElementRef);
}
export declare class ItemDivider {
    /**
     * The color to use from your Sass `$colors` map. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information, see [Theming your App](/docs/theming/theming-your-app).
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`. For more information, see [Platform Styles](/docs/theming/platform-specific-styles).
     */
    mode: any;
    constructor(el: ElementRef);
}
export declare class ItemGroup {
}
export declare class ItemOption {
    /**
     * The color to use from your Sass `$colors` map. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information, see [Theming your App](/docs/theming/theming-your-app).
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`. For more information, see [Platform Styles](/docs/theming/platform-specific-styles).
     */
    mode: any;
    /**
     * If true, the user cannot interact with the item option. Defaults to `false`.
     */
    disabled: boolean;
    /**
     * If true, the option will expand to take up the available width and cover any other options. Defaults to `false`.
     */
    expandable: boolean;
    /**
     * Contains a URL or a URL fragment that the hyperlink points to. If this property is set, an anchor tag will be rendered.
     */
    href: string;
    constructor(el: ElementRef);
}
export declare class ItemOptions {
    /**
     * The side the option button should be on. Defaults to `"right"`. If you have multiple `ion-item-options`, a side must be provided for each.
     */
    side: any;
    ionSwipe: NgEventEmitter<any>;
    constructor(el: ElementRef);
}
export declare class ItemSliding {
    ionDrag: NgEventEmitter<any>;
    constructor();
}
export declare class Label {
    /**
     * The color to use from your Sass `$colors` map. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information, see [Theming your App](/docs/theming/theming-your-app).
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`. For more information, see [Platform Styles](/docs/theming/platform-specific-styles).
     */
    mode: any;
    /**
     * If true, the label will sit alongside an input. Defaults to `false`.
     */
    fixed: boolean;
    /**
     * If true, the label will float above an input when the value is empty or the input is focused. Defaults to `false`.
     */
    floating: boolean;
    /**
     * If true, the label will be stacked above an input. Defaults to `false`.
     */
    stacked: boolean;
    ionStyle: NgEventEmitter<any>;
    constructor(el: ElementRef);
}
export declare class List {
}
export declare class ListHeader {
    /**
     * The color to use from your Sass `$colors` map. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information, see [Theming your App](/docs/theming/theming-your-app).
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`. For more information, see [Platform Styles](/docs/theming/platform-specific-styles).
     */
    mode: any;
    constructor(el: ElementRef);
}
export declare class Menu {
    /**
     * The content's id the menu should use.
     */
    contentId: string;
    /**
     * An id for the menu.
     */
    menuId: string;
    /**
     * The display type of the menu. Default varies based on the mode, see the `menuType` in the [config](../../config/Config). Available options: `"overlay"`, `"reveal"`, `"push"`.
     */
    type: string;
    /**
     * If true, the menu is disabled. Default `false`.
     */
    disabled: boolean;
    /**
     * Which side of the view the menu should be placed. Default `"start"`.
     */
    side: any;
    /**
     * If true, swiping the menu is enabled. Default `true`.
     */
    swipeEnabled: boolean;
    /**
     * If true, the menu will persist on child pages.
     */
    persistent: boolean;
    maxEdgeStart: number;
    ionOpen: NgEventEmitter<any>;
    ionClose: NgEventEmitter<any>;
    ionMenuChange: NgEventEmitter<any>;
    constructor(el: ElementRef);
}
export declare class MenuButton {
    /**
     * Optional property that maps to a Menu's `menuId` prop. Can also be `left` or `right` for the menu side. This is used to find the correct menu to toggle
     */
    menu: string;
    /**
     * Automatically hides the menu button when the corresponding menu is not active
     */
    autoHide: boolean;
    constructor(el: ElementRef);
}
export declare class MenuToggle {
    /**
     * Optional property that maps to a Menu's `menuId` prop. Can also be `left` or `right` for the menu side. This is used to find the correct menu to toggle
     */
    menu: string;
    /**
     * Automatically hides the content when the corresponding menu is not active
     */
    autoHide: boolean;
    constructor(el: ElementRef);
}
export declare class Nav {
    swipeBackEnabled: boolean;
    animated: boolean;
    delegate: any;
    rootParams: any;
    root: any;
    ionNavWillChange: NgEventEmitter<any>;
    ionNavDidChange: NgEventEmitter<any>;
    constructor(el: ElementRef);
}
export declare class NavPop {
}
export declare class NavPush {
    component: any;
    componentProps: any;
    url: string;
    constructor(el: ElementRef);
}
export declare class NavSetRoot {
    component: any;
    componentProps: any;
    url: string;
    constructor(el: ElementRef);
}
export declare class Note {
    /**
     * The color to use from your Sass `$colors` map. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information, see [Theming your App](/docs/theming/theming-your-app).
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`. For more information, see [Platform Styles](/docs/theming/platform-specific-styles).
     */
    mode: any;
    constructor(el: ElementRef);
}
export declare class Radio {
    /**
     * The color to use from your Sass `$colors` map. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information, see [Theming your App](/docs/theming/theming-your-app).
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`. For more information, see [Platform Styles](/docs/theming/platform-specific-styles).
     */
    mode: any;
    /**
     * The name of the control, which is submitted with the form data.
     */
    name: string;
    /**
     * Indicates that the user cannot interact with the control.
     */
    disabled: boolean;
    /**
     * If true, the radio is selected. Defaults to `false`.
     */
    checked: boolean;
    /**
     * the value of the radio.
     */
    value: string;
    ionRadioDidLoad: NgEventEmitter<any>;
    ionRadioDidUnload: NgEventEmitter<any>;
    ionStyle: NgEventEmitter<any>;
    ionSelect: NgEventEmitter<any>;
    ionFocus: NgEventEmitter<any>;
    ionBlur: NgEventEmitter<any>;
    constructor(el: ElementRef);
}
export declare class RadioGroup {
    allowEmptySelection: boolean;
    /**
     * Indicates that the user cannot interact with the control.
     */
    disabled: boolean;
    /**
     * The name of the control, which is submitted with the form data.
     */
    name: string;
    /**
     * the value of the radio group.
     */
    value: string;
    ionChange: NgEventEmitter<any>;
    constructor(el: ElementRef);
}
export declare class Range {
    /**
     * The color to use from your Sass `$colors` map. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information, see [Theming your App](/docs/theming/theming-your-app).
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`. For more information, see [Platform Styles](/docs/theming/platform-specific-styles).
     */
    mode: any;
    /**
     * How long, in milliseconds, to wait to trigger the `ionChange` event after each change in the range value. Default `0`.
     */
    debounce: number;
    disabled: boolean;
    /**
     * Show two knobs. Defaults to `false`.
     */
    dualKnobs: boolean;
    /**
     * Maximum integer value of the range. Defaults to `100`.
     */
    max: number;
    /**
     * Minimum integer value of the range. Defaults to `0`.
     */
    min: number;
    /**
     * If true, a pin with integer value is shown when the knob is pressed. Defaults to `false`.
     */
    pin: boolean;
    /**
     * If true, the knob snaps to tick marks evenly spaced based on the step property value. Defaults to `false`.
     */
    snaps: boolean;
    /**
     * Specifies the value granularity. Defaults to `1`.
     */
    step: number;
    /**
     * the value of the range.
     */
    value: any;
    ionChange: NgEventEmitter<any>;
    ionStyle: NgEventEmitter<any>;
    ionFocus: NgEventEmitter<any>;
    ionBlur: NgEventEmitter<any>;
    constructor(el: ElementRef);
}
export declare class Refresher {
    /**
     * The minimum distance the user must pull down until the refresher will go into the `refreshing` state. Defaults to `60`.
     */
    pullMin: number;
    /**
     * The maximum distance of the pull until the refresher will automatically go into the `refreshing` state. Defaults to the result of `pullMin + 60`.
     */
    pullMax: any;
    /**
     * Time it takes to close the refresher. Defaults to `280ms`.
     */
    closeDuration: string;
    /**
     * Time it takes the refresher to to snap back to the `refreshing` state. Defaults to `280ms`.
     */
    snapbackDuration: string;
    /**
     * If true, the refresher will be hidden. Defaults to `true`.
     */
    disabled: boolean;
    ionRefresh: NgEventEmitter<any>;
    ionPull: NgEventEmitter<any>;
    ionStart: NgEventEmitter<any>;
    constructor(el: ElementRef);
}
export declare class RefresherContent {
    /**
     * A static icon to display when you begin to pull down
     */
    pullingIcon: string;
    /**
     * The text you want to display when you begin to pull down
     */
    pullingText: string;
    /**
     * An animated SVG spinner that shows when refreshing begins
     */
    refreshingSpinner: string;
    /**
     * The text you want to display when performing a refresh
     */
    refreshingText: string;
    constructor(el: ElementRef);
}
export declare class Reorder {
}
export declare class ReorderGroup {
    /**
     * If true, the reorder will be hidden. Defaults to `true`.
     */
    disabled: boolean;
    constructor(el: ElementRef);
}
export declare class RippleEffect {
    useTapClick: boolean;
    constructor(el: ElementRef);
}
export declare class Row {
}
export declare class Scroll {
    mode: string;
    /**
     * If true and the content does not cause an overflow scroll, the scroll interaction will cause a bounce. If the content exceeds the bounds of ionScroll, nothing will change. Note, the does not disable the system bounce on iOS. That is an OS level setting.
     */
    forceOverscroll: boolean;
    scrollEvents: boolean;
    ionScrollStart: NgEventEmitter<any>;
    ionScroll: NgEventEmitter<any>;
    ionScrollEnd: NgEventEmitter<any>;
    constructor(el: ElementRef);
}
export declare class Searchbar {
    /**
     * The color to use from your Sass `$colors` map. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information, see [Theming your App](/docs/theming/theming-your-app).
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`. For more information, see [Platform Styles](/docs/theming/platform-specific-styles).
     */
    mode: any;
    /**
     * If true, enable searchbar animation. Default `false`.
     */
    animated: boolean;
    /**
     * Set the input's autocomplete property. Values: `"on"`, `"off"`. Default `"off"`.
     */
    autocomplete: string;
    /**
     * Set the input's autocorrect property. Values: `"on"`, `"off"`. Default `"off"`.
     */
    autocorrect: string;
    /**
     * Set the the cancel button text. Default: `"Cancel"`.
     */
    cancelButtonText: string;
    /**
     * Set the amount of time, in milliseconds, to wait to trigger the `ionInput` event after each keystroke. Default `250`.
     */
    debounce: number;
    /**
     * Set the input's placeholder. Default `"Search"`.
     */
    placeholder: string;
    /**
     * If true, show the cancel button. Default `false`.
     */
    showCancelButton: boolean;
    /**
     * If true, enable spellcheck on the input. Default `false`.
     */
    spellcheck: boolean;
    /**
     * Set the type of the input. Values: `"text"`, `"password"`, `"email"`, `"number"`, `"search"`, `"tel"`, `"url"`. Default `"search"`.
     */
    type: string;
    /**
     * the value of the searchbar.
     */
    value: string;
    ionInput: NgEventEmitter<any>;
    ionCancel: NgEventEmitter<any>;
    ionClear: NgEventEmitter<any>;
    ionBlur: NgEventEmitter<any>;
    ionFocus: NgEventEmitter<any>;
    constructor(el: ElementRef);
}
export declare class Segment {
    /**
     * The color to use for the text color. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`.
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`.
     */
    mode: any;
    disabled: boolean;
    /**
     * the value of the segment.
     */
    value: string;
    ionChange: NgEventEmitter<any>;
    constructor(el: ElementRef);
}
export declare class SegmentButton {
    activated: boolean;
    /**
     * The color to use for the text color. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`.
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`.
     */
    mode: any;
    /**
     * If true, the segment button is selected. Defaults to `false`.
     */
    checked: boolean;
    disabled: boolean;
    /**
     * Contains a URL or a URL fragment that the hyperlink points to. If this property is set, an anchor tag will be rendered.
     */
    href: string;
    /**
     * The value of the segment button.
     */
    value: string;
    ionClick: NgEventEmitter<any>;
    constructor(el: ElementRef);
}
export declare class Select {
    /**
     * If true, the user cannot interact with the select. Defaults to `false`.
     */
    disabled: boolean;
    /**
     * The text to display on the cancel button. Default: `Cancel`.
     */
    cancelText: string;
    /**
     * The text to display on the ok button. Default: `OK`.
     */
    okText: string;
    /**
     * The text to display when the select is empty.
     */
    placeholder: string;
    /**
     * The name of the control, which is submitted with the form data.
     */
    name: string;
    /**
     * The text to display instead of the selected option's value.
     */
    selectedText: string;
    /**
     * If true, the select can accept multiple values.
     */
    multiple: boolean;
    /**
     * The interface the select should use: `action-sheet`, `popover` or `alert`. Default: `alert`.
     */
    interface: string;
    /**
     * Any additional options that the `alert`, `action-sheet` or `popover` interface can take. See the [AlertController API docs](../../alert/AlertController/#create), the [ActionSheetController API docs](../../action-sheet/ActionSheetController/#create) and the [PopoverController API docs](../../popover/PopoverController/#create) for the create options for each interface.
     */
    interfaceOptions: any;
    /**
     * the value of the select.
     */
    value: any;
    ionChange: NgEventEmitter<any>;
    ionCancel: NgEventEmitter<any>;
    ionFocus: NgEventEmitter<any>;
    ionBlur: NgEventEmitter<any>;
    ionStyle: NgEventEmitter<any>;
    constructor(el: ElementRef);
}
export declare class SelectOption {
    /**
     * If true, the user cannot interact with the select option. Defaults to `false`.
     */
    disabled: boolean;
    /**
     * If true, the element is selected.
     */
    selected: boolean;
    /**
     * The text value of the option.
     */
    value: any;
    ionSelectOptionDidLoad: NgEventEmitter<any>;
    ionSelectOptionDidUnload: NgEventEmitter<any>;
    constructor(el: ElementRef);
}
export declare class SelectPopover {
    header: string;
    subHeader: string;
    message: string;
    options: any;
    constructor(el: ElementRef);
}
export declare class ShowWhen {
    orientation: string;
    mediaQuery: string;
    size: string;
    mode: string;
    platform: string;
    or: boolean;
    constructor(el: ElementRef);
}
export declare class SkeletonText {
    width: string;
    constructor(el: ElementRef);
}
export declare class Slide {
}
export declare class Slides {
    /**
     * Options to pass to the swiper instance. See http://idangero.us/swiper/api/ for valid options
     */
    options: any;
    /**
     * Show or hide the pager
     */
    pager: boolean;
    ionSlideWillChange: NgEventEmitter<any>;
    ionSlideDidChange: NgEventEmitter<any>;
    ionSlideNextStart: NgEventEmitter<any>;
    ionSlidePrevStart: NgEventEmitter<any>;
    ionSlideNextEnd: NgEventEmitter<any>;
    ionSlidePrevEnd: NgEventEmitter<any>;
    ionSlideTransitionStart: NgEventEmitter<any>;
    ionSlideTransitionEnd: NgEventEmitter<any>;
    ionSlideDrag: NgEventEmitter<any>;
    ionSlideReachStart: NgEventEmitter<any>;
    ionSlideReachEnd: NgEventEmitter<any>;
    ionSlideTouchStart: NgEventEmitter<any>;
    ionSlideTouchEnd: NgEventEmitter<any>;
    constructor(el: ElementRef);
}
export declare class Spinner {
    /**
     * The color to use from your Sass `$colors` map. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information, see [Theming your App](/docs/theming/theming-your-app).
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`. For more information, see [Platform Styles](/docs/theming/platform-specific-styles).
     */
    mode: any;
    /**
     * Duration of the spinner animation in milliseconds. The default varies based on the spinner.
     */
    duration: number;
    /**
     * The name of the SVG spinner to use. If a name is not provided, the platform's default spinner will be used. Possible values are: `"lines"`, `"lines-small"`, `"dots"`, `"bubbles"`, `"circles"`, `"crescent"`.
     */
    name: string;
    /**
     * If true, the spinner's animation will be paused. Defaults to `false`.
     */
    paused: boolean;
    constructor(el: ElementRef);
}
export declare class SplitPane {
    /**
     * If true, the split pane will be hidden. Defaults to `false`.
     */
    disabled: boolean;
    /**
     * When the split-pane should be shown. Can be a CSS media query expression, or a shortcut expression. Can also be a boolean expression.
     */
    when: any;
    ionChange: NgEventEmitter<any>;
    ionSplitPaneVisible: NgEventEmitter<any>;
    constructor(el: ElementRef);
}
export declare class Tab {
    active: boolean;
    btnId: string;
    delegate: any;
    /**
     * The title of the tab.
     */
    tabTitle: string;
    /**
     * The URL which will be used as the `href` within this tab's `<ion-tab-button>` anchor.
     */
    href: string;
    /**
     * The icon for the tab.
     */
    tabIcon: string;
    /**
     * The badge for the tab.
     */
    tabBadge: string;
    /**
     * The badge color for the tab button.
     */
    tabBadgeStyle: string;
    /**
     * The component to display inside of the tab.
     */
    component: any;
    /**
     * The name of the tab.
     */
    name: string;
    /**
     * If true, the user cannot interact with the tab. Defaults to `false`.
     */
    disabled: boolean;
    /**
     * If true, the tab will be selected. Defaults to `false`.
     */
    selected: boolean;
    /**
     * If true, the tab button is visible within the tabbar. Defaults to `true`.
     */
    show: boolean;
    /**
     * If true, hide the tabs on child pages.
     */
    tabsHideOnSubPages: boolean;
    ionSelect: NgEventEmitter<any>;
    constructor(el: ElementRef);
}
export declare class Tabs {
    /**
     * The color to use from your Sass `$colors` map. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information, see [Theming your App](/docs/theming/theming-your-app).
     */
    color: string;
    /**
     * A unique name for the tabs
     */
    name: string;
    /**
     * If true, the tabbar
     */
    tabbarHidden: boolean;
    /**
     * Set the tabbar layout: `icon-top`, `icon-start`, `icon-end`, `icon-bottom`, `icon-hide`, `title-hide`.
     */
    tabbarLayout: string;
    /**
     * Set position of the tabbar: `top`, `bottom`.
     */
    tabbarPlacement: string;
    /**
     * If true, show the tab highlight bar under the selected tab.
     */
    tabbarHighlight: boolean;
    /**
     * If true, the tabs will be translucent. Note: In order to scroll content behind the tabs, the `fullscreen` attribute needs to be set on the content. Defaults to `false`.
     */
    translucent: boolean;
    scrollable: boolean;
    useRouter: boolean;
    ionChange: NgEventEmitter<any>;
    ionNavWillChange: NgEventEmitter<any>;
    ionNavDidChange: NgEventEmitter<any>;
    constructor(el: ElementRef);
}
export declare class Text {
    /**
     * The color to use from your Sass `$colors` map. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information, see [Theming your App](/docs/theming/theming-your-app).
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`. For more information, see [Platform Styles](/docs/theming/platform-specific-styles).
     */
    mode: any;
    constructor(el: ElementRef);
}
export declare class Textarea {
    /**
     * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user. Defaults to `"none"`.
     */
    autocapitalize: string;
    /**
     * Indicates whether the value of the control can be automatically completed by the browser. Defaults to `"off"`.
     */
    autocomplete: string;
    /**
     * This Boolean attribute lets you specify that a form control should have input focus when the page loads. Defaults to `false`.
     */
    autofocus: boolean;
    /**
     * If true, the value will be cleared after focus upon edit. Defaults to `true` when `type` is `"password"`, `false` for all other types.
     */
    clearOnEdit: boolean;
    /**
     * Set the amount of time, in milliseconds, to wait to trigger the `ionInput` event after each keystroke. Default `0`.
     */
    debounce: number;
    /**
     * If true, the user cannot interact with the textarea. Defaults to `false`.
     */
    disabled: boolean;
    /**
     * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the maximum number of characters that the user can enter.
     */
    maxlength: number;
    /**
     * If the value of the type attribute is `text`, `email`, `search`, `password`, `tel`, or `url`, this attribute specifies the minimum number of characters that the user can enter.
     */
    minlength: number;
    /**
     * The name of the control, which is submitted with the form data.
     */
    name: string;
    /**
     * Instructional text that shows before the input has a value.
     */
    placeholder: string;
    /**
     * If true, the user cannot modify the value. Defaults to `false`.
     */
    readonly: boolean;
    /**
     * If true, the user must fill in a value before submitting a form.
     */
    required: boolean;
    /**
     * If true, the element will have its spelling and grammar checked. Defaults to `false`.
     */
    spellcheck: boolean;
    /**
     * The visible width of the text control, in average character widths. If it is specified, it must be a positive integer.
     */
    cols: number;
    /**
     * The number of visible text lines for the control.
     */
    rows: number;
    /**
     * Indicates how the control wraps text. Possible values are: `"hard"`, `"soft"`, `"off"`.
     */
    wrap: string;
    /**
     * The value of the textarea.
     */
    value: string;
    ionInput: NgEventEmitter<any>;
    ionStyle: NgEventEmitter<any>;
    ionBlur: NgEventEmitter<any>;
    ionFocus: NgEventEmitter<any>;
    constructor(el: ElementRef);
}
export declare class Thumbnail {
}
export declare class Toggle {
    /**
     * The color to use from your Sass `$colors` map. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information, see [Theming your App](/docs/theming/theming-your-app).
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`. For more information, see [Platform Styles](/docs/theming/platform-specific-styles).
     */
    mode: any;
    /**
     * The name of the control, which is submitted with the form data.
     */
    name: string;
    /**
     * If true, the toggle is selected. Defaults to `false`.
     */
    checked: boolean;
    /**
     * Indicates that the user cannot interact with the control.
     */
    disabled: boolean;
    /**
     * the value of the toggle.
     */
    value: string;
    ionChange: NgEventEmitter<any>;
    ionFocus: NgEventEmitter<any>;
    ionBlur: NgEventEmitter<any>;
    ionStyle: NgEventEmitter<any>;
    constructor(el: ElementRef);
}
export declare class Toolbar {
    /**
     * The color to use from your Sass `$colors` map. Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`. For more information, see [Theming your App](/docs/theming/theming-your-app).
     */
    color: string;
    /**
     * The mode determines which platform styles to use. Possible values are: `"ios"` or `"md"`. For more information, see [Platform Styles](/docs/theming/platform-specific-styles).
     */
    mode: any;
    /**
     * If true, the toolbar will be translucent. Note: In order to scroll content behind the toolbar, the `fullscreen` attribute needs to be set on the content. Defaults to `false`.
     */
    translucent: boolean;
    constructor(el: ElementRef);
}
export declare class ToolbarTitle {
}
