export class StackController {
    constructor(stack, containerEl, router, navCtrl) {
        this.stack = stack;
        this.containerEl = containerEl;
        this.router = router;
        this.navCtrl = navCtrl;
        this.viewsSnapshot = [];
        this.views = [];
    }
    createView(enteringRef, route) {
        return {
            ref: enteringRef,
            element: (enteringRef && enteringRef.location && enteringRef.location.nativeElement),
            url: this.getUrl(route),
            deactivatedId: -1
        };
    }
    getExistingView(activatedRoute) {
        const activatedUrlKey = this.getUrl(activatedRoute);
        return this.views.find(vw => vw.url === activatedUrlKey);
    }
    canGoBack(deep) {
        return this.views.length > deep;
    }
    async setActive(enteringView, direction) {
        const leavingView = this.getActive();
        const reused = this.insertView(enteringView);
        direction = direction != null ? direction : (reused ? -1 : 1);
        await this.transition(enteringView, leavingView, direction, this.canGoBack(1));
        this.cleanup();
    }
    pop(deep) {
        const view = this.views[this.views.length - deep - 1];
        this.navCtrl.setGoback();
        this.router.navigateByUrl(view.url);
    }
    insertView(enteringView) {
        if (this.stack) {
            const index = this.views.indexOf(enteringView);
            if (index >= 0) {
                this.views = this.views.slice(0, index + 1);
                return true;
            }
            else {
                this.views.push(enteringView);
                return false;
            }
        }
        else {
            this.views = [enteringView];
            return false;
        }
    }
    cleanup() {
        this.viewsSnapshot
            .filter(view => !this.views.includes(view))
            .forEach(view => destroyView(view));
        for (let i = 0; i < this.views.length - 1; i++) {
            this.views[i].element.hidden = true;
        }
        this.viewsSnapshot = this.views.slice();
    }
    getActive() {
        return this.views.length > 0 ? this.views[this.views.length - 1] : null;
    }
    async transition(enteringView, leavingView, direction, showGoBack) {
        const enteringEl = enteringView ? enteringView.element : undefined;
        const leavingEl = leavingView ? leavingView.element : undefined;
        const containerEl = this.containerEl;
        if (enteringEl && enteringEl !== leavingEl) {
            enteringEl.classList.add('ion-page', 'hide-page');
            containerEl.appendChild(enteringEl);
            await containerEl.componentOnReady();
            await containerEl.commit(enteringEl, leavingEl, {
                duration: direction === 0 ? 0 : undefined,
                direction: direction === -1 ? "back" /* Back */ : "forward" /* Forward */,
                showGoBack
            });
        }
    }
    getUrl(activatedRoute) {
        const urlTree = this.router.createUrlTree(['.'], { relativeTo: activatedRoute });
        return this.router.serializeUrl(urlTree);
    }
}
export function destroyView(view) {
    if (view) {
        // TODO lifecycle event
        view.ref.destroy();
    }
}
export function getLastDeactivatedRef(views) {
    if (views.length < 2) {
        return null;
    }
    return views.sort((a, b) => {
        if (a.deactivatedId > b.deactivatedId)
            return -1;
        if (a.deactivatedId < b.deactivatedId)
            return 1;
        return 0;
    })[0].ref;
}
